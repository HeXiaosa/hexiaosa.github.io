<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Hexiaosa">
<meta property="og:url" content="http://hexiaosa.com/index.html">
<meta property="og:site_name" content="Hexiaosa">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexiaosa">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://hexiaosa.com/"/>





  <title>Hexiaosa</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexiaosa</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Startseite
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archiv
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hexiaosa.com/2018/09/01/RecyclerView/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hexiaosa">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexiaosa">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/01/RecyclerView/" itemprop="url">RecycleView 缓存机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-09-01T23:06:37+08:00">
                2018-09-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>RecyclerView 的使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">RecyclerView lv = (RecyclerView) findViewById(R.id.lv);</div><div class="line">lv.setLayoutManager(new LinearLayoutManager(getApplicationContext(), LinearLayoutManager.VERTICAL, false));</div><div class="line">lv.setAdapter(new MyListAdapter(getApplicationContext()));</div></pre></td></tr></table></figure></p>
<p>setLayoutManager 给 RecyclerView 设置了 mLayout, setAdapter 设置 mAdapter, 清除缓存的一些信息，并 requestLayout. RecyclerView 执行 onLayout 过程中，会调用 mLayout.layoutChildren 方法，然后到 LinearLayoutManager 的 layoutChildren 方法，fill(recycler, mLayoutState, state, false) 再到 layoutChunk 方法中看，第一行代码就是 layoutState.next(recycler), 进去看这个方法，这个方法获取了下一个需要 layout 的 view, 看下源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">if (mScrapList != null) &#123;</div><div class="line">	// mScrapList 不为 null, 则取 mScrapList 中的 View</div><div class="line">    return nextViewFromScrapList();</div><div class="line">&#125;</div><div class="line">// mScrapList 为 null, 则继续查找 view, 从 getViewForPosition, tryGetViewHolderForPositionByDeadline 方法看</div><div class="line">final View view = recycler.getViewForPosition(mCurrentPosition);</div><div class="line">mCurrentPosition += mItemDirection;</div><div class="line">return view;</div></pre></td></tr></table></figure></p>
<p>tryGetViewHolderForPositionByDeadline 方法，主要查缓存 View 的地方<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">ViewHolder tryGetViewHolderForPositionByDeadline(int position,</div><div class="line">        boolean dryRun, long deadlineNs) &#123;</div><div class="line">    boolean fromScrapOrHiddenOrCache = false;</div><div class="line">    ViewHolder holder = null;</div><div class="line">    // 0) 首先从 mChangeScrap 中查</div><div class="line">    if (mState.isPreLayout()) &#123;</div><div class="line">        holder = getChangedScrapViewForPosition(position);</div><div class="line">        fromScrapOrHiddenOrCache = holder != null;</div><div class="line">    &#125;</div><div class="line">    // 1) 没有找到就从 mAttachView 或 mCacheView 中查</div><div class="line">    if (holder == null) &#123;</div><div class="line">        holder = getScrapOrHiddenOrCachedHolderForPosition(position, dryRun);</div><div class="line">        if (holder != null) &#123;</div><div class="line">            // ...</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    if (holder == null) &#123;</div><div class="line">        final int type = mAdapter.getItemViewType(offsetPosition);</div><div class="line">        // 2) 通过 stableIs 在 mAttachView 和 mCacheView 中查</div><div class="line">        if (mAdapter.hasStableIds()) &#123;</div><div class="line">            holder = getScrapOrCachedViewForId(mAdapter.getItemId(offsetPosition),</div><div class="line">                    type, dryRun);</div><div class="line">            if (holder != null) &#123;</div><div class="line">                // ...</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        if (holder == null &amp;&amp; mViewCacheExtension != null) &#123;</div><div class="line">            // 通过 mViewCacheExtension 查</div><div class="line">        &#125;</div><div class="line">        if (holder == null) &#123; // 从 mRecyclerPool 中查</div><div class="line">            holder = getRecycledViewPool().getRecycledView(type);</div><div class="line">            if (holder != null) &#123;</div><div class="line">                // ...</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        if (holder == null) &#123;</div><div class="line">        	// 自己创建 View, 也就是我们自己实现的 onCreateViewHolder 方法</div><div class="line">            holder = mAdapter.createViewHolder(RecyclerView.this, type);</div><div class="line">            // ...</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // ...</div><div class="line"></div><div class="line">    // 设置 layoutParams</div><div class="line">    return holder;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>layout 过程中就是以上面的方式获取缓存的 View, 然后加到 RecyclerView 中。</p>
<p>下面再看滑动过程中 item 是怎么复用的，RecyclerView 的 onTouchEvent 方法 ACTION_MOVE 事件中调用了 mGapWorker.postFromTraversal(this, dx, dy), 接着到 GapWorker 中看，它的 postFromTraversal 方法主要执行了 recycleview.post(this), GapWorker 是一个 Runnable, 那么执行的就是 GapWorker 的 run() 方法，在这里面一直跟进去 prefetch, flushTasksWithDeadline, prefetchPositionWithDeadline, 我们能看到在 prefetchPositionWithDeadline 方法中同样调了 recycler.tryGetViewHolderForPositionByDeadline 来获取缓存中的 ViewHolder, 所以滑动过程中 item 的复用就是这样实现的。</p>
<p>好吧，分析的不是很清晰，先到这里吧，继续看源码(<em>^▽^</em>)</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hexiaosa.com/2018/08/29/ListView/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hexiaosa">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexiaosa">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/29/ListView/" itemprop="url">从 ListView 源码讲解缓存复用流程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-29T23:50:29+08:00">
                2018-08-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>ListView 中缓使用了 RecycleBin(AbsListView 的内部类), 它内部有几个重要的成员变量：<br>mScrapViews : 多种 viewType 时，缓存 viewType 个 view<br>mCurrentScrap : 一种 viewType 时，缓存一个 view<br>mActiveViews : 缓存屏幕上显示的 view, 用于在 layout 过程中复用 view</p>
<p>首先分析 ListView 的绘制流程，onLayout 方法重写是在 AbsListView 中，这里会调用 ListView 的 layoutChildren, 主要代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">protected void layoutChildren() &#123;</div><div class="line">	// ...</div><div class="line">    try &#123;</div><div class="line">    	// ...</div><div class="line">        if (mAdapter == null) &#123;</div><div class="line">            // ...</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        // ...</div><div class="line">        // 两次 layout, 第一次 layout 还没有子 View, childCount 是 0, 第二次才有正常的值，屏幕显示的 View 数量</div><div class="line">        final int childCount = getChildCount();</div><div class="line"></div><div class="line">        int index = 0;</div><div class="line">        int delta = 0;</div><div class="line"></div><div class="line">        View sel;</div><div class="line">        View oldSel = null;</div><div class="line">        View oldFirst = null;</div><div class="line">        View newSel = null;</div><div class="line"></div><div class="line">        // Remember stuff we will need down below</div><div class="line">        switch (mLayoutMode) &#123;</div><div class="line">        // ...</div><div class="line">        default: // LAYOUT_NORMAL 执行到这里</div><div class="line">            // 记录之前选中，first 等</div><div class="line">        &#125;</div><div class="line">        // 这里处理 notifyDataSetChanged 时的逻辑</div><div class="line">        boolean dataChanged = mDataChanged;</div><div class="line">        if (dataChanged) &#123;</div><div class="line">            handleDataChanged();</div><div class="line">        &#125;</div><div class="line">        // ...</div><div class="line">        // 开始缓存 View, 使用 RecycleBin</div><div class="line">        final int firstPosition = mFirstPosition;</div><div class="line">        final RecycleBin recycleBin = mRecycler;</div><div class="line">        if (dataChanged) &#123;</div><div class="line">        	// 更新内容时在这里处理</div><div class="line">            for (int i = 0; i &lt; childCount; i++) &#123;</div><div class="line">                recycleBin.addScrapView(getChildAt(i), firstPosition+i);</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">        	// 初始第二次 layout 时执行到这里，fillActiveViews 时除了 header 和 footer 的 显示在屏幕上的 child 都存到 mActiveViews</div><div class="line">            recycleBin.fillActiveViews(childCount, firstPosition);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 清除旧的子 view</div><div class="line">        detachAllViewsFromParent();</div><div class="line">        recycleBin.removeSkippedScrap();</div><div class="line"></div><div class="line">        switch (mLayoutMode) &#123;</div><div class="line">        // ...</div><div class="line">        default: // LAYOUT_NORMAL 的逻辑在 default 中，layout 方法中缓存相关的也就是在这里</div><div class="line">            if (childCount == 0) &#123; // 两次 layout, 第一次时没有 child, 所以在这里处理，填充 View</div><div class="line">                if (!mStackFromBottom) &#123;</div><div class="line">                    final int position = lookForSelectablePosition(0, true);</div><div class="line">                    setSelectedPositionInt(position);</div><div class="line">                    // fillDown -&gt; makeAndAddView -&gt; </div><div class="line">                    // (getActiveView, 没有的话 obtainView&lt;这里调用了 getView 方法，传过去的 convertView 从 transientVStateView/scapeView 中取，convertView 是 null 则自己 inflate&gt;</div><div class="line">                    // , setupChild&lt;layout child, 需要再测量时测量 child&gt;)</div><div class="line">                    sel = fillFromTop(childrenTop); </div><div class="line">                &#125; else &#123;</div><div class="line">                    final int position = lookForSelectablePosition(mItemCount - 1, false);</div><div class="line">                    setSelectedPositionInt(position);</div><div class="line">                    sel = fillUp(mItemCount - 1, childrenBottom);</div><div class="line">                &#125;</div><div class="line">            &#125; else &#123; // 第二次 layout 在这里处理，填充 View, 这里 view 不会再 inflate, 会使用 mActiveView 中缓存的</div><div class="line">                if (mSelectedPosition &gt;= 0 &amp;&amp; mSelectedPosition &lt; mItemCount) &#123;</div><div class="line">                    sel = fillSpecific(mSelectedPosition,</div><div class="line">                            oldSel == null ? childrenTop : oldSel.getTop());</div><div class="line">                &#125; else if (mFirstPosition &lt; mItemCount) &#123;</div><div class="line">                    sel = fillSpecific(mFirstPosition,</div><div class="line">                            oldFirst == null ? childrenTop : oldFirst.getTop());</div><div class="line">                &#125; else &#123;</div><div class="line">                    sel = fillSpecific(0, childrenTop);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 把屏幕上显示的 View 转移到废弃 View 的缓存中，由于上面调用 fillSpecific 方法时，会把屏幕显示 View item 已置空，所以这一步废弃 View 并缓存不了东西</div><div class="line">        recycleBin.scrapActiveViews();</div><div class="line"></div><div class="line">        // ...</div><div class="line">        </div><div class="line">        // 设置一些选中，焦点，以及恢复一些默认值</div><div class="line"></div><div class="line">        invokeOnItemScrollListener();</div><div class="line">    &#125; finally &#123;</div><div class="line">        // ...</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>layout 的流程，第一次屏幕上的 view 都是 inflate 得到的，第二次 layout 时，把子 view 存到 mActiveViews 中，取出来重新 layout</p>
<p>上面就是 layout 的过程，那么滑动中 view 是怎么复用的呢，这是在 onTouchEvent 中控制的，接下来看 onTouchEvent 的流程<br>onTouchEvent -&gt; onTouchMove -&gt; scrollIfNeeded -&gt; trackMotionScroll -&gt; fillGap -&gt; fillDown -&gt; makeAndAddView, 这里 obtainView 就是主要在 scapeView 得到复用 View 了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hexiaosa.com/2018/08/22/asynctask-theory/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hexiaosa">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexiaosa">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/22/asynctask-theory/" itemprop="url">AsyncTask 详解与思考</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-22T18:24:03+08:00">
                2018-08-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>先上一段熟悉的代码，AsyncTask 的使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">MyAsyncTask task = new MyAsyncTask();</div><div class="line">task.execute(&quot;1&quot;);</div><div class="line"></div><div class="line">private class MyAsyncTask extends AsyncTask&lt;String, Void, String&gt; &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onPreExecute() &#123;</div><div class="line">        Log.e(&quot;TAG&quot;, &quot;onPreExecute THREAD:&quot; + Thread.currentThread());</div><div class="line">        super.onPreExecute();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected String doInBackground(String... params) &#123;</div><div class="line">        Log.e(&quot;TAG&quot;, &quot;doInBackground start &quot; + params[0] + &quot; THREAD:&quot; + Thread.currentThread());</div><div class="line">        try &#123;</div><div class="line">            Thread.sleep(2000);</div><div class="line">        &#125; catch (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        Log.e(&quot;TAG&quot;, &quot;doInBackground end&quot;);</div><div class="line">        return &quot;1&quot;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onPostExecute(String s) &#123;</div><div class="line">        Log.e(&quot;TAG&quot;, &quot;onPostExecute:&quot; + s + &quot; THREAD:&quot; + Thread.currentThread());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>以上代码的输出：<br>onPreExecute THREAD:Thread[main,5,main]<br>doInBackground start 1 THREAD:Thread[AsyncTask #3,5,main]<br>doInBackground end<br>onPostExecute:1 THREAD:Thread[main,5,main]</p>
<p>可以看到 doInBackground 在子线程中执行，onPostExecute 在主线程执行。</p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>先从源码分析一下整个执行的流程(以下源码来自 api-25)</p>
<p>AsyncTask 中重要的列举几个成员变量：<br>THREAD_POOL_EXECUTOR : 内部线程池<br>sDefaultExecutor :  负责排队取方法执行的<br>sHandler : 内部 Handler, 用于切换主线程的<br>mWorker : 封装了 doInBackground 方法，mWorker 的 call 方法中调用 doInBackground, 执行完后调用 postResult<br>mFuture : 封装了 mWorker, 在 mFuture 的 run 方法中调用 mWorker.call, 执行完后再处理一些</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div></pre></td><td class="code"><pre><div class="line">AsyncTask 的构造函数</div><div class="line">public AsyncTask() &#123;</div><div class="line">	// 初始化 mWorker, 后面执行时候会用到</div><div class="line">    mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123;</div><div class="line">        public Result call() throws Exception &#123;</div><div class="line">            mTaskInvoked.set(true);</div><div class="line">            Result result = null;</div><div class="line">            try &#123;</div><div class="line">                Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</div><div class="line">                // 实际执行 doInBackground</div><div class="line">                result = doInBackground(mParams);</div><div class="line">                Binder.flushPendingCommands();</div><div class="line">            &#125; catch (Throwable tr) &#123;</div><div class="line">                mCancelled.set(true);</div><div class="line">                throw tr;</div><div class="line">            &#125; finally &#123;</div><div class="line">            	// 处理返回结果，切换主线程到 onPostResult</div><div class="line">                postResult(result);</div><div class="line">            &#125;</div><div class="line">            return result;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    mFuture = new FutureTask&lt;Result&gt;(mWorker) &#123;</div><div class="line">        @Override</div><div class="line">        protected void done() &#123;</div><div class="line">            // ... 意外处理</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// execute 方法，注解声明了必须在主线程调用此方法</div><div class="line">@MainThread</div><div class="line">public final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) &#123;</div><div class="line">    return executeOnExecutor(sDefaultExecutor, params);</div><div class="line">&#125;</div><div class="line">@MainThread</div><div class="line">public final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec,</div><div class="line">        Params... params) &#123;</div><div class="line">    if (mStatus != Status.PENDING) &#123;</div><div class="line">        // ...</div><div class="line">    &#125;</div><div class="line">    mStatus = Status.RUNNING;</div><div class="line">    // 我们可以实现的 onPreExecute 方法，这时还没有切换线程，所以该方法是在主线程执行</div><div class="line">    onPreExecute();</div><div class="line">    // 开始执行 doInBackground 方法</div><div class="line">    mWorker.mParams = params;</div><div class="line">    exec.execute(mFuture);</div><div class="line"></div><div class="line">    return this;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 上面的 sDefaultExecutor 是下面这个类：</div><div class="line">private static class SerialExecutor implements Executor &#123;</div><div class="line">    final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;();</div><div class="line">    Runnable mActive;</div><div class="line">    // 这里的参数 r 就是 mFuture</div><div class="line">    public synchronized void execute(final Runnable r) &#123;</div><div class="line">    	// 挨个从队列中取出，一个执行完再取下一个</div><div class="line">        mTasks.offer(new Runnable() &#123;</div><div class="line">            public void run() &#123;</div><div class="line">                try &#123;</div><div class="line">                	// 执行 mFuture.run()，方法实现看下一段代码</div><div class="line">                    r.run();</div><div class="line">                &#125; finally &#123;</div><div class="line">                    scheduleNext();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        if (mActive == null) &#123;</div><div class="line">            scheduleNext();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    protected synchronized void scheduleNext() &#123;</div><div class="line">        if ((mActive = mTasks.poll()) != null) &#123;</div><div class="line">        	// 子线程实际开始执行，THREAD_POOL_EXECUTOR 是线程池</div><div class="line">            THREAD_POOL_EXECUTOR.execute(mActive);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// FutureTask 的 run 方法</div><div class="line">public void run() &#123;</div><div class="line">    // ...</div><div class="line">    try &#123;</div><div class="line">    	// callable 是 AsyncTask 的 mWorker</div><div class="line">        Callable&lt;V&gt; c = callable;</div><div class="line">        if (c != null &amp;&amp; state == NEW) &#123;</div><div class="line">            V result;</div><div class="line">            boolean ran;</div><div class="line">            try &#123;</div><div class="line">            	// 执行 mWorker.call(), mWorker 在 AsyncTask 的构造函数中重写了 call 方法，</div><div class="line">            	// 里面执行了 result = doInBackground(mParams); 这个就是我们必须实现的方法</div><div class="line">            	// 接下来看 postResult(result);</div><div class="line">                result = c.call();</div><div class="line">                ran = true;</div><div class="line">            &#125; catch (Throwable ex) &#123;</div><div class="line">                // ...</div><div class="line">            &#125;</div><div class="line">            if (ran)</div><div class="line">                set(result);</div><div class="line">        &#125;</div><div class="line">    &#125; finally &#123;</div><div class="line">        // ...</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// mWorker 执行完 doInBackground 后</div><div class="line">private Result postResult(Result result) &#123;</div><div class="line">    // getHandler() 返回的是内部 Handler 类 InternalHandler, </div><div class="line">    // 这里处理了 MESSAGE_POST_RESULT : result.mTask.finish(result.mData[0]); </div><div class="line">    // finish 就是调用 onPostResult, 所以切主线程就是在这里</div><div class="line">    Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT,</div><div class="line">            new AsyncTaskResult&lt;Result&gt;(this, result));</div><div class="line">    message.sendToTarget();</div><div class="line">    return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>到这里源码部分已分析完成，有几个值得思考的问题</p>
<h5 id="1-AsyncTask-不同版本的区分"><a href="#1-AsyncTask-不同版本的区分" class="headerlink" title="1. AsyncTask 不同版本的区分"></a>1. AsyncTask 不同版本的区分</h5><p>AsyncTask 版本变动较大是从 api-11(3.0) 之后，上面源码分析的是来自 api-25, 是更新后的版本，多次调用 execute 对于同一个 AsyncTask 会执行完一个再执行下一个，但是 api-10(包括) 之前的版本是并行执行的，调用 exceute 内部的线程池就去执行（除非线程池满需排队等待）。下面来看一下 api-10 的源码处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) &#123;</div><div class="line">    //...</div><div class="line">    onPreExecute();</div><div class="line">    // sExecutor 执行，sExecutor 是线程池，直接执行了 call 方法，没有去排队</div><div class="line">    mWorker.mParams = params;</div><div class="line">    sExecutor.execute(mFuture);</div><div class="line">    return this;</div><div class="line">&#125;</div><div class="line">// sExecutor, 核心线程数量是 5, 最大线程数是 128. </div><div class="line">// 而新版本的 AsyncTask 核心线程数是 Math.max(2, Math.min(CPU_COUNT - 1, 4)), 最大线程数是 CPU_COUNT * 2 + 1</div><div class="line">private static final ThreadPoolExecutor sExecutor = new ThreadPoolExecutor(CORE_POOL_SIZE,</div><div class="line">        MAXIMUM_POOL_SIZE, KEEP_ALIVE, TimeUnit.SECONDS, sWorkQueue, sThreadFactory);</div></pre></td></tr></table></figure></p>
<h5 id="2-AsyncTask-是否可以取消"><a href="#2-AsyncTask-是否可以取消" class="headerlink" title="2. AsyncTask 是否可以取消"></a>2. AsyncTask 是否可以取消</h5><p>AsyncTask 提供了 cancel 方法来取消，需传一个 boolean 类型的参数，true 表示会 intercept 中断 doInBackground, false 不会中断 doInBackground, 它会完整地执行完。true/false 都不会再执行 onPostResult 方法。</p>
<h5 id="3-AsyncTask-的缺点"><a href="#3-AsyncTask-的缺点" class="headerlink" title="3. AsyncTask 的缺点"></a>3. AsyncTask 的缺点</h5><ol>
<li>内部类形式时可能持有外部类引用，或者 。导致内存泄漏或异常<br>–&gt; 解决方法：改为静态内部类</li>
<li>Activity 已被销毁，doInBackground 还没有执行完，执行完后再执行 onPostResult, 导致产生异常<br>–&gt; 解决方法：Activity 的 onDestroy 方法中调 cancel 方法取消 AsyncTask</li>
<li>AsyncTask 内部封装了线程池，比较适合多次执行的时候使用，当仅需要在子线程执行一些简单操作时使用 AsyncTask 会浪费消耗。<br>–&gt; 解决方法：根据场景决定是否使用 AsyncTask</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hexiaosa.com/2018/08/21/rxjava-theory/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hexiaosa">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexiaosa">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/21/rxjava-theory/" itemprop="url">RxJava 从源码分析流程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-21T19:06:32+08:00">
                2018-08-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>以下面这段代码为示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">public void run(final ThreadListener&lt;T&gt; listener) &#123;</div><div class="line">    Observable.create(new ObservableOnSubscribe&lt;T&gt;() &#123;</div><div class="line">        @Override</div><div class="line">        public void subscribe(ObservableEmitter&lt;T&gt; e) throws Exception &#123;</div><div class="line">            listener.start(e);</div><div class="line">        &#125;</div><div class="line">    &#125;).subscribeOn(Schedulers.io())</div><div class="line">            .observeOn(AndroidSchedulers.mainThread())</div><div class="line">            .subscribe(new Observer&lt;T&gt;() &#123;</div><div class="line">                @Override</div><div class="line">                public void onSubscribe(Disposable d) &#123;</div><div class="line"></div><div class="line">                &#125;</div><div class="line"></div><div class="line">                @Override</div><div class="line">                public void onNext(T t) &#123;</div><div class="line">                    listener.onNext(t);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                @Override</div><div class="line">                public void onError(Throwable e) &#123;</div><div class="line">                    listener.onError(e.getMessage());</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                @Override</div><div class="line">                public void onComplete() &#123;</div><div class="line"></div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>源码流程就看下面这个手画的图吧：<br><img src="/image/rxjava_flow.jpg" alt="rxjava_flow"></p>
<p>可以看到类是一层一层被包裹的，那么当 ObservableEmitter 执行 e.next() 时，会调到 ObservableObserveOn 的内部类 ObserveOnObserver 的 onNext 方法, onNext 方法中调了 schedule, schedule 方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">void schedule() &#123;</div><div class="line">    if (getAndIncrement() == 0) &#123;</div><div class="line">        worker.schedule(this); // worker 是 HandlerScheduler.createWorker, 返回的是 HandlerScheduler 的内部类 HandlerWorker</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>wordker.schedule 的主要代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public Disposable schedule(Runnable run, long delay, TimeUnit unit) &#123;</div><div class="line">	// 这里的 handler 是 new Handler(Looper.getMainLooper())</div><div class="line">    ScheduledRunnable scheduled = new ScheduledRunnable(handler, run);</div><div class="line"></div><div class="line">    Message message = Message.obtain(handler, scheduled);</div><div class="line">    message.obj = this; // Used as token for batch disposal of this worker&apos;s runnables.</div><div class="line">    // 这里切换到主线程</div><div class="line">    handler.sendMessageDelayed(message, Math.max(0L, unit.toMillis(delay)));</div><div class="line"></div><div class="line">    return scheduled;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>所以接下来会执行 ScheduledRunnable 的 run 方法，接着执行到 run 方法中，会调用 drainNormal<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">void drainNormal() &#123;</div><div class="line">    // ...</div><div class="line">    final Observer&lt;? super T&gt; a = actual;</div><div class="line">    for (;;) &#123;</div><div class="line">    	// ...</div><div class="line">        for (;;) &#123;</div><div class="line">        	// ...</div><div class="line">            try &#123;</div><div class="line">            	// ...</div><div class="line">            &#125; catch (Throwable ex) &#123;</div><div class="line">                // ...</div><div class="line">                a.onError(ex);</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line">            // ...</div><div class="line">            // 这里执行 onNext 方法，也就是会执行到我们实现的代码</div><div class="line">            a.onNext(v);</div><div class="line">        &#125;</div><div class="line">        // ...</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hexiaosa.com/2018/08/21/ReentrantLock-theory/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hexiaosa">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexiaosa">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/21/ReentrantLock-theory/" itemprop="url">ReentrantLock 原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-21T18:29:48+08:00">
                2018-08-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>ReentrantReadWriteLock 是通过加锁来保证线程安全的，它是 Java 源码中内置的加锁的类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ReentrantReadWriteLock lock = new ReentrantReadWriteLock();</div><div class="line">try &#123;</div><div class="line">    lock.writeLock().lock();</div><div class="line">&#125; finally &#123;</div><div class="line">    lock.writeLock().unlock();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么它内部是通过什么方式来实现加锁的呢，通过以下源码中的注释便可清楚。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public ReentrantReadWriteLock() &#123;</div><div class="line">    this(false); // 默认是 false</div><div class="line">&#125;</div><div class="line">public ReentrantReadWriteLock(boolean fair) &#123;</div><div class="line">    // 默认是不公平锁</div><div class="line">    sync = fair ? new FairSync() : new NonfairSync();</div><div class="line">    readerLock = new ReadLock(this);</div><div class="line">    writerLock = new WriteLock(this);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>先来看 WriteLock 的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">// WriteLock</div><div class="line">public void lock() &#123;</div><div class="line">    sync.acquire(1);</div><div class="line">&#125;</div><div class="line">// Sync继承自 AbstractQueuedSynchronizer, acquire 方法是在 AbstractQueuedSynchronizer 里实现的</div><div class="line">public final void acquire(int arg) &#123;</div><div class="line">    // 主要控制同步的逻辑在 tryAcquire</div><div class="line">    if (!tryAcquire(arg) &amp;&amp;</div><div class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</div><div class="line">        selfInterrupt(); // 如果没有获取到锁，当前线程中断</div><div class="line">&#125;</div><div class="line">// Sync 类中 tryAcquire 方法的实现</div><div class="line">protected final boolean tryAcquire(int acquires) &#123;</div><div class="line">    Thread current = Thread.currentThread();</div><div class="line">    int c = getState(); // 持有该锁的数量</div><div class="line">    int w = exclusiveCount(c);</div><div class="line">    if (c != 0) &#123;</div><div class="line">        // 已经有持有该锁的</div><div class="line">        if (w == 0 || current != getExclusiveOwnerThread())</div><div class="line">            return false; // 持有锁的线程不是当前线程</div><div class="line">        if (w + exclusiveCount(acquires) &gt; MAX_COUNT)</div><div class="line">            throw new Error(&quot;Maximum lock count exceeded&quot;);</div><div class="line">        // 同一线程，如果是嵌套的，这里就是可重入锁的原理所在</div><div class="line">        setState(c + acquires);</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line">    // 还没有持有该锁的，如果写数量失败了，就返回 false</div><div class="line">    if (writerShouldBlock() ||</div><div class="line">        !compareAndSetState(c, c + acquires))</div><div class="line">        return false;</div><div class="line">    // 设置持有锁的线程是当前线程</div><div class="line">    setExclusiveOwnerThread(current);</div><div class="line">    return true;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>到这里加锁主要逻辑就结束了，那么解锁的呢？接着往下看，解锁跟加锁的过程比较类似<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">// WriteLock</div><div class="line">public void unlock() &#123;</div><div class="line">    sync.release(1);</div><div class="line">&#125;</div><div class="line">// Sync继承自 AbstractQueuedSynchronizer, acquire 方法是在 AbstractQueuedSynchronizer 里实现的</div><div class="line">public final boolean release(int arg) &#123;</div><div class="line">    // 解锁的主要逻辑在 tryRelease</div><div class="line">    if (tryRelease(arg)) &#123;</div><div class="line">        // ...</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line">    return false;</div><div class="line">&#125;</div><div class="line">// Sync 类的 tryRelease 实现</div><div class="line">protected final boolean tryRelease(int releases) &#123;</div><div class="line">    // ...</div><div class="line">    int nextc = getState() - releases; // 剩余的锁的数量</div><div class="line">    boolean free = exclusiveCount(nextc) == 0; // 是否已经没有锁</div><div class="line">    if (free)</div><div class="line">        setExclusiveOwnerThread(null); // 如果已经没有锁，则持有线程置为 null</div><div class="line">    setState(nextc); // 设置剩余锁的数量</div><div class="line">    return free; // 返回是否已经不再持有锁</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>总结：ReentrantLock 就是通过设置当前持有锁的线程和持有锁的数量，加锁时候通过判断这些来决定是否能获取锁，如果暂时不能获取锁，则线程中断。解锁过程是修改相应的持有锁线程和持有锁数量。</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hexiaosa.com/2018/08/15/view-onDraw-LineChart/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hexiaosa">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexiaosa">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/15/view-onDraw-LineChart/" itemprop="url">自定义 View ———— 折线图（重写 onDraw方法）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-15T20:55:08+08:00">
                2018-08-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>实现一个如下效果的折线图<br><img src="/image/line_result.jpg" alt="line_result"></p>
<p>这样的效果实现的方式很容易想到的就是重写 onDraw 方法，给定一组 float 值，分别画点、线，那么下面有颜色的阴影部分是用什么画呢，就用到了 Path, 一个点一个点相连成一个封闭的图形，便可画出这个图形。如果先画点，再画阴影部分，是会把点遮住一部分的，所以实现的时候先画完了阴影部分，再画线和点。不过这样子在 onDraw 方法里就有两个 for 循环，如果有好的办法欢迎提出。（邮箱：hexiaosa91@163.com）<br>下面直接贴出 View 的整个代码，代码不多</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @author hexiaosa</div><div class="line"> * @date 2018/8/15</div><div class="line"> */</div><div class="line"></div><div class="line">public class CustomLineChart extends View &#123;</div><div class="line"></div><div class="line">    private int width; // 宽</div><div class="line">    private int height; // 高</div><div class="line">    private int pointNum; // 折点个数</div><div class="line">    private int lineColor; // 折线颜色</div><div class="line">    private int shadowColor; // 阴影颜色</div><div class="line">    private float[] percents; // 百分比，可以理解为任务完成百分比</div><div class="line">    private int itemWidth;</div><div class="line">    private Path path; // 避免在 onDraw 方法内创建多个对象，所以在这里声明一个成员变量</div><div class="line"></div><div class="line">    public CustomLineChart(Context context) &#123;</div><div class="line">        this(context, null);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public CustomLineChart(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        this(context, attrs, 0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public CustomLineChart(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123;</div><div class="line">        super(context, attrs, defStyleAttr);</div><div class="line"></div><div class="line">        // 线颜色，阴影颜色，折点个数</div><div class="line">        TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.CustomLineChart);</div><div class="line">        lineColor = typedArray.getColor(R.styleable.CustomLineChart_lineColor, Color.BLACK);</div><div class="line">        shadowColor = typedArray.getColor(R.styleable.CustomLineChart_shadowColor, Color.BLACK);</div><div class="line">        pointNum = typedArray.getInteger(R.styleable.CustomLineChart_pointNum, 0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        if (pointNum == 0) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        if (percents == null || percents.length != pointNum) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        if (width == 0) &#123;</div><div class="line">            width = getMeasuredWidth();</div><div class="line">        &#125;</div><div class="line">        if (height == 0) &#123;</div><div class="line">            height = getMeasuredHeight();</div><div class="line">        &#125;</div><div class="line">        if (path == null) &#123;</div><div class="line">            path = new Path();</div><div class="line">        &#125;</div><div class="line">        itemWidth = width/(pointNum-1);</div><div class="line">        Paint paint = new Paint();</div><div class="line">        paint.setStrokeWidth(5);</div><div class="line">        // 阴影部分使用 Path 连接成一个封闭图形</div><div class="line">        path.reset();</div><div class="line">        path.moveTo(0, height);</div><div class="line">        path.lineTo(0, height*(1-percents[0]));</div><div class="line">        for (int i = 1; i &lt; percents.length; i++) &#123;</div><div class="line">            // 连接阴影</div><div class="line">            path.lineTo(itemWidth*i, height*(1-percents[i]));</div><div class="line">        &#125;</div><div class="line">        path.lineTo(width, height);</div><div class="line">        path.lineTo(0, height);</div><div class="line">        paint.setColor(shadowColor);</div><div class="line">        // 画阴影</div><div class="line">        canvas.drawPath(path, paint);</div><div class="line">        path.close();</div><div class="line"></div><div class="line">        paint.setColor(lineColor);</div><div class="line">        canvas.drawCircle(0, height*(1-percents[0]), 10, paint);</div><div class="line">        for (int i = 1; i &lt; percents.length; i++) &#123;</div><div class="line">            // 画线</div><div class="line">            canvas.drawLine(itemWidth*(i-1), height*(1-percents[i-1]), itemWidth*i, height*(1-percents[i]), paint);</div><div class="line">            // 画点</div><div class="line">            canvas.drawCircle(itemWidth*i, height*(1-percents[i]), 10, paint);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        canvas.save();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public void setPercents(float[] percents) &#123;</div><div class="line">        this.percents = percents;</div><div class="line">        invalidate();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setLineColor(int lineColor) &#123;</div><div class="line">        this.lineColor = lineColor;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setShadowColor(int shadowColor) &#123;</div><div class="line">        this.shadowColor = shadowColor;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setPointNum(int pointNum) &#123;</div><div class="line">        this.pointNum = pointNum;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// attr.xml</div><div class="line">    &lt;declare-styleable name=&quot;CustomLineChart&quot;&gt;</div><div class="line">        &lt;attr name=&quot;lineColor&quot; format=&quot;color&quot;/&gt;</div><div class="line">        &lt;attr name=&quot;shadowColor&quot; format=&quot;color&quot;/&gt;</div><div class="line">        &lt;attr name=&quot;pointNum&quot; format=&quot;integer&quot;/&gt;</div><div class="line">    &lt;/declare-styleable&gt;</div></pre></td></tr></table></figure>
<p>使用示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">CustomLineChart clc = (CustomLineChart) findViewById(R.id.clc);</div><div class="line">// 必须设置，还有 pointNum 在布局或代码设置至少有一个地方设置，且 pointNum 需等于 percents.length</div><div class="line">clc.setPercents(new float[]&#123;0.5f, 0.3f, 0.4f, 0.7f, 0.1f, 0.2f, 0.6f, 0.8f, 0.9f, 1f&#125;);</div></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hexiaosa.com/2018/08/15/retrofit/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hexiaosa">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexiaosa">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/15/retrofit/" itemprop="url">Retrofit 源码分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-15T20:47:33+08:00">
                2018-08-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Retrofit-使用例子"><a href="#Retrofit-使用例子" class="headerlink" title="Retrofit 使用例子"></a>Retrofit 使用例子</h3><p>下面只展示了异步请求示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">Retrofit retrofit = new Retrofit.Builder()</div><div class="line">        .baseUrl(&quot;https://api.github.com&quot;)</div><div class="line">        .build();</div><div class="line"></div><div class="line">GitHubService service = retrofit.create(GitHubService.class);</div><div class="line">service.search().enqueue(new retrofit2.Callback&lt;String&gt;() &#123;</div><div class="line">    @Override</div><div class="line">    public void onResponse(retrofit2.Call&lt;String&gt; call, retrofit2.Response&lt;String&gt; response) &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onFailure(retrofit2.Call&lt;String&gt; call, Throwable t) &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>Retrofit 中使用了 OkHttp, 分析到后面就可以看到。<br>先来看创建 Retrofit 吧：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public Retrofit build() &#123;</div><div class="line">	// ...</div><div class="line">	okhttp3.Call.Factory callFactory = this.callFactory;</div><div class="line">	if (callFactory == null) &#123;</div><div class="line">		// 创建 callFactory 对象，也就是 Retrofit 的 callFactory.</div><div class="line">		callFactory = new OkHttpClient();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	Executor callbackExecutor = this.callbackExecutor;</div><div class="line">	if (callbackExecutor == null) &#123;</div><div class="line">		// 创建 callbackExecutor 对象，platform 是 Android 的实例，其 defaultCallbackExecutor 方法返回的是 ExecutorCallAdapterFactory 对象</div><div class="line">		callbackExecutor = platform.defaultCallbackExecutor();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	List&lt;CallAdapter.Factory&gt; callAdapterFactories = new ArrayList&lt;&gt;(this.callAdapterFactories);</div><div class="line">	// 把上面创建的 callbackExecutor 添加到 callAdapterFactories 中</div><div class="line">	callAdapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor));</div><div class="line">	// ...</div><div class="line">	return new Retrofit(callFactory, baseUrl, unmodifiableList(converterFactories),</div><div class="line">	  unmodifiableList(callAdapterFactories), callbackExecutor, validateEagerly);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面代码主要创建了 retrofit 对象，还创建了这几个稍等分析会用到的对象，callFactory、callbackExecutor.</p>
<p>下面接着往下看 retrofit.create 方法，这里使用了代理模式，create 创建的 GitHubService 对象可以调用 search 方法，search 方法的执行就在代理的实现里面，这个就一起分析了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">public &lt;T&gt; T create(final Class&lt;T&gt; service) &#123;</div><div class="line">	Utils.validateServiceInterface(service);</div><div class="line">	if (validateEagerly) &#123;</div><div class="line">	    eagerlyValidateMethods(service);</div><div class="line">	&#125;</div><div class="line">	// 代理实现, service.search 走的就是这里的 invoke 方法</div><div class="line">	return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] &#123; service &#125;,</div><div class="line">	    new InvocationHandler() &#123;</div><div class="line">			private final Platform platform = Platform.get();</div><div class="line"></div><div class="line">			@Override public Object invoke(Object proxy, Method method, @Nullable Object[] args)</div><div class="line">			  throws Throwable &#123;</div><div class="line">			// If the method is a method from Object then defer to normal invocation.</div><div class="line">				if (method.getDeclaringClass() == Object.class) &#123;</div><div class="line">				  return method.invoke(this, args);</div><div class="line">				&#125;</div><div class="line">				if (platform.isDefaultMethod(method)) &#123;</div><div class="line">				  return platform.invokeDefaultMethod(method, service, proxy, args);</div><div class="line">				&#125;</div><div class="line">				// 这里是主要内容</div><div class="line">				/* 封装 ServiceMethod 对象，创建 ServiceMethod 对象时创建了 callAdapter 实例，callAdapter 是 retrofit.callAdapter(returnType, annotations), 再往里看就是 retrofit 的成员变量 callAdapterFactories.get(i).get(returnType, annotations, this), callAdapterFactories 是在创建 retrofit 时，里面存的是 ExecutorCallAdapterFactory 对象</div><div class="line">					    return new CallAdapter&lt;Object, Call&lt;?&gt;&gt;() &#123;</div><div class="line">					      @Override public Type responseType() &#123;</div><div class="line">					        return responseType;</div><div class="line">					      &#125;</div><div class="line"></div><div class="line">					      @Override public Call&lt;Object&gt; adapt(Call&lt;Object&gt; call) &#123;</div><div class="line">					        return new ExecutorCallbackCall&lt;&gt;(callbackExecutor, call);</div><div class="line">					      &#125;</div><div class="line">					    &#125;;</div><div class="line">			    这就是 ServiceMethod 的 callAdapter 对象</div><div class="line">				 */</div><div class="line">				ServiceMethod&lt;Object, Object&gt; serviceMethod =</div><div class="line">				    (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method);</div><div class="line">				// 创建 OkHttpCall</div><div class="line">				OkHttpCall&lt;Object&gt; okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args);</div><div class="line">				// 其中 callAdapter 在封装 ServiceMethod 对象时创建的，执行的 callAdapter.adapt(call) 返回的就是 new ExecutorCallbackCall&lt;&gt;(callbackExecutor, call)</div><div class="line">				return serviceMethod.adapt(okHttpCall);</div><div class="line">			&#125;</div><div class="line">	    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到 service.search 返回的是 ExecutorCallbackCall 对象，它的成员变量 delegate 是上面创建的 OkHttpCall 对象，那么接下来的 enqueue 方法就是 ExecutorCallbackCall 的 enqueue 了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div></pre></td><td class="code"><pre><div class="line">    @Override public void enqueue(final Callback&lt;T&gt; callback) &#123;</div><div class="line">		checkNotNull(callback, &quot;callback == null&quot;);</div><div class="line">        // 主要看下面这一点，delegata.enqueue, delegate 是 OkHttpCall 对象，那接着看下一个 OkHttpCall 的 enqueue 方法把</div><div class="line">		delegate.enqueue(new Callback&lt;T&gt;() &#123;</div><div class="line">		@Override public void onResponse(Call&lt;T&gt; call, final Response&lt;T&gt; response) &#123;</div><div class="line">		  callbackExecutor.execute(new Runnable() &#123;</div><div class="line">		    @Override public void run() &#123;</div><div class="line">				if (delegate.isCanceled()) &#123;</div><div class="line">					// Emulate OkHttp&apos;s behavior of throwing/delivering an IOException on cancellation.</div><div class="line">					callback.onFailure(ExecutorCallbackCall.this, new IOException(&quot;Canceled&quot;));</div><div class="line">				&#125; else &#123;</div><div class="line">					callback.onResponse(ExecutorCallbackCall.this, response);</div><div class="line">				&#125;</div><div class="line">		    &#125;</div><div class="line">		  &#125;);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		@Override public void onFailure(Call&lt;T&gt; call, final Throwable t) &#123;</div><div class="line">			callbackExecutor.execute(new Runnable() &#123;</div><div class="line">				@Override public void run() &#123;</div><div class="line">				    callback.onFailure(ExecutorCallbackCall.this, t);</div><div class="line">				&#125;</div><div class="line">			&#125;);</div><div class="line">		&#125;</div><div class="line">		&#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">@Override public void enqueue(final Callback&lt;T&gt; callback) &#123;</div><div class="line">	checkNotNull(callback, &quot;callback == null&quot;);</div><div class="line"></div><div class="line">	okhttp3.Call call;</div><div class="line">	Throwable failure;</div><div class="line"></div><div class="line">	synchronized (this) &#123;</div><div class="line">		if (executed) throw new IllegalStateException(&quot;Already executed.&quot;);</div><div class="line">		executed = true;</div><div class="line"></div><div class="line">		call = rawCall;</div><div class="line">		failure = creationFailure;</div><div class="line">		if (call == null &amp;&amp; failure == null) &#123;</div><div class="line">			try &#123;</div><div class="line">				// 创建 call 对象，serviceMethod.toCall -&gt; callFactory.newCall(callFactory 就是在最开始创建 retrofit 对象的 OkHttpClient 实例) -&gt; okHttpClient.newCall(这里使用的就是 OkHttp 框架的了) -&gt; RealCall</div><div class="line">			    call = rawCall = createRawCall();</div><div class="line">			&#125; catch (Throwable t) &#123;</div><div class="line">			    throwIfFatal(t);</div><div class="line">			    failure = creationFailure = t;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	if (failure != null) &#123;</div><div class="line">		callback.onFailure(this, failure);</div><div class="line">		return;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	if (canceled) &#123;</div><div class="line">		call.cancel();</div><div class="line">	&#125;</div><div class="line">	// call 是 RealCall 对象，接下来的 enqueue 方法跟分析 OkHttp 的就一样了</div><div class="line">	call.enqueue(new okhttp3.Callback() &#123;</div><div class="line">		@Override public void onResponse(okhttp3.Call call, okhttp3.Response rawResponse) &#123;</div><div class="line">			Response&lt;T&gt; response;</div><div class="line">			try &#123;</div><div class="line">			    response = parseResponse(rawResponse);</div><div class="line">			&#125; catch (Throwable e) &#123;</div><div class="line">			    callFailure(e);</div><div class="line">			    return;</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			try &#123;</div><div class="line">			    callback.onResponse(OkHttpCall.this, response);</div><div class="line">			&#125; catch (Throwable t) &#123;</div><div class="line">			    t.printStackTrace();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		@Override public void onFailure(okhttp3.Call call, IOException e) &#123;</div><div class="line">			callFailure(e);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		private void callFailure(Throwable e) &#123;</div><div class="line">			try &#123;</div><div class="line">			    callback.onFailure(OkHttpCall.this, e);</div><div class="line">			&#125; catch (Throwable t) &#123;</div><div class="line">			    t.printStackTrace();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hexiaosa.com/2018/08/14/OkHttp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hexiaosa">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexiaosa">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/14/OkHttp/" itemprop="url">OkHttp 源码分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-14T21:16:41+08:00">
                2018-08-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="OkHttp-使用代码实例"><a href="#OkHttp-使用代码实例" class="headerlink" title="OkHttp 使用代码实例"></a>OkHttp 使用代码实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">private static final MediaType JSON</div><div class="line">        = MediaType.parse(&quot;application/json; charset=utf-8&quot;);</div><div class="line">OkHttpClient client = new OkHttpClient();</div><div class="line"></div><div class="line">String post(String url, String json) throws IOException &#123;</div><div class="line">    RequestBody body = RequestBody.create(JSON, json);</div><div class="line">    Request request = new Request.Builder()</div><div class="line">            .url(url)</div><div class="line">            .post(body)</div><div class="line">            .build();</div><div class="line">    // 同步调用</div><div class="line">    Response response = client.newCall(request).execute();</div><div class="line">    // 异步调用</div><div class="line">    client.newCall(request).enqueue(new Callback() &#123;</div><div class="line">        @Override</div><div class="line">        public void onFailure(Call call, IOException e) &#123;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void onResponse(Call call, Response response) throws IOException &#123;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    return response.body().string();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>先来看 new OkHttpClient()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">public OkHttpClient() &#123;</div><div class="line">this(new Builder());</div><div class="line">&#125;</div><div class="line"></div><div class="line">public Builder() &#123;</div><div class="line">    // 创建了 Dispatcher 对象</div><div class="line">	dispatcher = new Dispatcher();</div><div class="line">	protocols = DEFAULT_PROTOCOLS;</div><div class="line">	connectionSpecs = DEFAULT_CONNECTION_SPECS;</div><div class="line">	eventListenerFactory = EventListener.factory(EventListener.NONE);</div><div class="line">	proxySelector = ProxySelector.getDefault();</div><div class="line">	cookieJar = CookieJar.NO_COOKIES;</div><div class="line">	socketFactory = SocketFactory.getDefault();</div><div class="line">	hostnameVerifier = OkHostnameVerifier.INSTANCE;</div><div class="line">	certificatePinner = CertificatePinner.DEFAULT;</div><div class="line">	proxyAuthenticator = Authenticator.NONE;</div><div class="line">	authenticator = Authenticator.NONE;</div><div class="line">	connectionPool = new ConnectionPool();</div><div class="line">	dns = Dns.SYSTEM;</div><div class="line">	followSslRedirects = true;</div><div class="line">	followRedirects = true;</div><div class="line">	retryOnConnectionFailure = true;</div><div class="line">	connectTimeout = 10_000;</div><div class="line">	readTimeout = 10_000;</div><div class="line">	writeTimeout = 10_000;</div><div class="line">	pingInterval = 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后 clien.newCall(request) 创建了 RealCall 对象，这也是 OkHttp 中一个重要的类，先来分析异步执行的源码吧，因为同步执行跟异步的后半段没什么区别了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@Override public void enqueue(Callback responseCallback) &#123;</div><div class="line">	synchronized (this) &#123;</div><div class="line">		if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);</div><div class="line">		executed = true;</div><div class="line">	&#125;</div><div class="line">	captureCallStackTrace();</div><div class="line">	eventListener.callStart(this);</div><div class="line">	// 执行 dispatcher 的 enqueue 方法，dispatcher 是在创建 HttpClient 对象时 new 的。注意这里传过去是的 new AsyncCall(responseCallback)</div><div class="line">	client.dispatcher().enqueue(new AsyncCall(responseCallback));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>AsyncCall 是实现了 NamedRunnable<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public abstract class NamedRunnable implements Runnable &#123;</div><div class="line">	// ...</div><div class="line">	@Override public final void run() &#123;</div><div class="line">		// ...</div><div class="line">		try &#123;</div><div class="line">			execute();</div><div class="line">		&#125; finally &#123;</div><div class="line">		    Thread.currentThread().setName(oldName);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	protected abstract void execute();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到就是实现的 Runnable 接口，如果在一个线程里执行，执行的就是 execute 方法。再接着看 dispatcher  的 enqueue 方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">synchronized void enqueue(AsyncCall call) &#123;</div><div class="line">	if (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</div><div class="line">		// 添加到执行队列</div><div class="line">	    runningAsyncCalls.add(call);</div><div class="line">	    // 在子线程执行方法，executorService 就是创建了线程池。</div><div class="line">	    executorService().execute(call);</div><div class="line">	&#125; else &#123;</div><div class="line">		// 添加到等待队列</div><div class="line">	    readyAsyncCalls.add(call);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>AsyncCall 执行的是 execute 方法，下面接着看这里<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">@Override protected void execute() &#123;</div><div class="line">	boolean signalledCallback = false;</div><div class="line">	try &#123;</div><div class="line">		// 责任链模式，链式调用的地方</div><div class="line">		Response response = getResponseWithInterceptorChain();</div><div class="line">		if (retryAndFollowUpInterceptor.isCanceled()) &#123;</div><div class="line">			signalledCallback = true;</div><div class="line">			// 返回回调失败</div><div class="line">			responseCallback.onFailure(RealCall.this, new IOException(&quot;Canceled&quot;));</div><div class="line">		&#125; else &#123;</div><div class="line">			signalledCallback = true;</div><div class="line">			// 返回回调成功</div><div class="line">			responseCallback.onResponse(RealCall.this, response);</div><div class="line">		&#125;</div><div class="line">	&#125; catch (IOException e) &#123;</div><div class="line">		if (signalledCallback) &#123;</div><div class="line">		    // Do not signal the callback twice!</div><div class="line">		    Platform.get().log(INFO, &quot;Callback failure for &quot; + toLoggableString(), e);</div><div class="line">		&#125; else &#123;</div><div class="line">		    eventListener.callFailed(RealCall.this, e);</div><div class="line">		    // 返回回调失败</div><div class="line">		    responseCallback.onFailure(RealCall.this, e);</div><div class="line">		&#125;</div><div class="line">	&#125; finally &#123;</div><div class="line">		// 从 dispatcher 的运行队列中清除该 Runnable</div><div class="line">		client.dispatcher().finished(this);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Response getResponseWithInterceptorChain() throws IOException &#123;</div><div class="line">	// Build a full stack of interceptors.</div><div class="line">	List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;();</div><div class="line">	// 添加自己定义的 interceptor</div><div class="line">	interceptors.addAll(client.interceptors());</div><div class="line">	// 重试</div><div class="line">	interceptors.add(retryAndFollowUpInterceptor);</div><div class="line">	// 转换</div><div class="line">	interceptors.add(new BridgeInterceptor(client.cookieJar()));</div><div class="line">	// 缓存</div><div class="line">	interceptors.add(new CacheInterceptor(client.internalCache()));</div><div class="line">	// 连接</div><div class="line">	interceptors.add(new ConnectInterceptor(client));</div><div class="line">	if (!forWebSocket) &#123;</div><div class="line">	    interceptors.addAll(client.networkInterceptors());</div><div class="line">	&#125;</div><div class="line">	// 请求服务器</div><div class="line">	interceptors.add(new CallServerInterceptor(forWebSocket));</div><div class="line"></div><div class="line">    // 开始链式调用</div><div class="line">	Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0,</div><div class="line">	    originalRequest, this, eventListener, client.connectTimeoutMillis(),</div><div class="line">	    client.readTimeoutMillis(), client.writeTimeoutMillis());</div><div class="line">	return chain.proceed(originalRequest);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>来一个链式调用的例子吧，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">// 实际执行</div><div class="line">public static void main(String[] args) &#123;</div><div class="line">	List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;();</div><div class="line">	interceptors.add(new Interceptor1());</div><div class="line">	interceptors.add(new Interceptor2());</div><div class="line">	InterceptorChain chain = new InterceptorChain(interceptors, 0);</div><div class="line">	chain.proceed();</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 执行链</div><div class="line">public class InterceptorChain &#123;</div><div class="line">	</div><div class="line">	private List&lt;Interceptor&gt; interceptors;</div><div class="line">	private int index;</div><div class="line">	</div><div class="line">	public InterceptorChain(List&lt;Interceptor&gt; interceptors, int index) &#123;</div><div class="line">		this.interceptors = interceptors;</div><div class="line">		this.index = index;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void proceed() &#123;</div><div class="line">		if (index &gt;= interceptors.size()) &#123;</div><div class="line">			System.out.println(&quot;调用完&quot;);</div><div class="line">			return;</div><div class="line">		&#125;</div><div class="line">		InterceptorChain chain = new InterceptorChain(interceptors, index+1);</div><div class="line">		Interceptor interceptor = interceptors.get(index);</div><div class="line">		interceptor.proceed(chain);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Interceptor</div><div class="line">public interface Interceptor &#123;</div><div class="line">	String proceed(InterceptorChain chain);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Interceptor1 implements Interceptor &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public String proceed(InterceptorChain chain) &#123;</div><div class="line">		System.out.println(&quot;Interceptor1 start&quot;);</div><div class="line">		chain.proceed();</div><div class="line">		System.out.println(&quot;Interceptor1 end&quot;);</div><div class="line">		return &quot;Interceptor1&quot;;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Interceptor2 implements Interceptor &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public String proceed(InterceptorChain chain) &#123;</div><div class="line">		System.out.println(&quot;Interceptor2 start&quot;);</div><div class="line">		chain.proceed();</div><div class="line">		System.out.println(&quot;Interceptor2 end&quot;);</div><div class="line">		return &quot;Interceptor2&quot;;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最终的执行结果是：<br>Interceptor1 start<br>Interceptor2 start<br>调用完<br>Interceptor2 end<br>Interceptor1 end</p>
<p>可以看到 1 先执行，在 1 里面调 2 的执行，2 执行完的返回结果，1 可以再进行处理。<br>来一张图解释下吧<br><img src="/image/interceptor_chain.jpg" alt="interceptor_chain"></p>
<p>OkHttp 的调用过程用下面的图来简介一下<br><img src="/image/OkHttp_chain.png" alt="OkHttp_chain"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hexiaosa.com/2018/08/14/toast/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hexiaosa">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexiaosa">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/14/toast/" itemprop="url">Toast 源码分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-14T21:15:28+08:00">
                2018-08-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>在分析源码之前有两个问题</p>
<ol>
<li><p>子线程直接使用 Toast 时会抛出异常 “Can’t create handler inside thread that has not called Looper.prepare()”, 在 Toast 类里搜 “Looper” 并搜不到。是哪里抛出的这个异常呢？</p>
</li>
<li><p>在子线程中这样使用 Toast:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Looper.prepare();</div><div class="line">Toast.makeText(getApplicationContext(), &quot;test toast&quot;, Toast.LENGTH_SHORT).show();</div><div class="line">Looper.loop();</div></pre></td></tr></table></figure>
</li>
</ol>
<p>像上面这种调用是在主线程显示 Toast 吗</p>
<h3 id="Toast-源码分析"><a href="#Toast-源码分析" class="headerlink" title="Toast 源码分析"></a>Toast 源码分析</h3><p>先看 Toast 的 makeText 和 show 方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">public static Toast makeText(Context context, CharSequence text, @Duration int duration) &#123;</div><div class="line">	// 创建 TN(Toast 的内置对象)，用于展示 Toast 的主要类</div><div class="line">    Toast result = new Toast(context);</div><div class="line"></div><div class="line">    // 加载 Toast 的展示内容</div><div class="line">    LayoutInflater inflate = (LayoutInflater)</div><div class="line">            context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);</div><div class="line">    View v = inflate.inflate(com.android.internal.R.layout.transient_notification, null);</div><div class="line">    TextView tv = (TextView)v.findViewById(com.android.internal.R.id.message);</div><div class="line">    tv.setText(text);</div><div class="line">    </div><div class="line">    // 赋值一些属性</div><div class="line">    result.mNextView = v;</div><div class="line">    result.mDuration = duration;</div><div class="line"></div><div class="line">    return result;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public void show() &#123;</div><div class="line">	// 校验显示内容</div><div class="line">    if (mNextView == null) &#123;</div><div class="line">        throw new RuntimeException(&quot;setView must have been called&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    INotificationManager service = getService(); // NotificationManagerService 的成员变量 mService 是 INotificationManager.Stub 的实现类</div><div class="line">    String pkg = mContext.getOpPackageName();</div><div class="line">    TN tn = mTN;</div><div class="line">    // 展示内容属性赋值给 tn 的属性</div><div class="line">    tn.mNextView = mNextView;</div><div class="line"></div><div class="line">    try &#123;</div><div class="line">    	// 调用 NotificationManagerService 中 mService 的 enqueueToast 方法</div><div class="line">        service.enqueueToast(pkg, tn, mDuration);</div><div class="line">    &#125; catch (RemoteException e) &#123;</div><div class="line">        // Empty</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下面来看 NotificationManagerService 中 mService 的 enqueueToast 方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">// callback 就是 TN 实例</div><div class="line">@Override</div><div class="line">public void enqueueToast(String pkg, ITransientNotification callback, int duration)</div><div class="line">&#123;</div><div class="line">    // ...</div><div class="line"></div><div class="line">    synchronized (mToastQueue) &#123;</div><div class="line">        int callingPid = Binder.getCallingPid();</div><div class="line">        long callingId = Binder.clearCallingIdentity();</div><div class="line">        try &#123;</div><div class="line">            ToastRecord record;</div><div class="line">            int index = indexOfToastLocked(pkg, callback);</div><div class="line">            // If it&apos;s already in the queue, we update it in place, we don&apos;t</div><div class="line">            // move it to the end of the queue.</div><div class="line">            if (index &gt;= 0) &#123;</div><div class="line">                record = mToastQueue.get(index);</div><div class="line">                record.update(duration);</div><div class="line">            &#125; else &#123;</div><div class="line">                // ...</div><div class="line"></div><div class="line">                Binder token = new Binder();</div><div class="line">                mWindowManagerInternal.addWindowToken(token,</div><div class="line">                        WindowManager.LayoutParams.TYPE_TOAST);</div><div class="line">                // 创建 ToastRecord 对象</div><div class="line">                record = new ToastRecord(callingPid, pkg, callback, duration, token);</div><div class="line">                // mToastQueue 添加记录</div><div class="line">                mToastQueue.add(record);</div><div class="line">                index = mToastQueue.size() - 1;</div><div class="line">                keepProcessAliveIfNeededLocked(callingPid);</div><div class="line">            &#125;</div><div class="line">            if (index == 0) &#123;</div><div class="line">                showNextToastLocked();</div><div class="line">            &#125;</div><div class="line">        &#125; finally &#123;</div><div class="line">            Binder.restoreCallingIdentity(callingId);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面代码可以看到有往 mToastQueue 中添加记录，那么什么时候执行呢，全局搜 “mToastQueue.get(“ 看到在 showNextToastLocked 方法中取出 mToastQueue 的第 0 个元素，调用 record.callback.show(record.token), record.callback 就是 TN 对象，也就是这里调了 TN 的 show 方法。下面就来看一下 TN 的 show 方法做了什么：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public void show(IBinder windowToken) &#123;</div><div class="line">    if (localLOGV) Log.v(TAG, &quot;SHOW: &quot; + this);</div><div class="line">    // 交给 mHandler 处理</div><div class="line">    mHandler.obtainMessage(0, windowToken).sendToTarget();</div><div class="line">&#125;</div><div class="line"></div><div class="line">// TN 的 mHandler</div><div class="line">final Handler mHandler = new Handler() &#123;</div><div class="line">    @Override</div><div class="line">    public void handleMessage(Message msg) &#123;</div><div class="line">    	// 所以 TN 的 show 方法处理的是这里</div><div class="line">        IBinder token = (IBinder) msg.obj;</div><div class="line">        handleShow(token);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>下面来看核心展示 Toast 的方法，也就是 TN 的 handleShow() 方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">public void handleShow(IBinder windowToken) &#123;</div><div class="line">    if (localLOGV) Log.v(TAG, &quot;HANDLE SHOW: &quot; + this + &quot; mView=&quot; + mView</div><div class="line">            + &quot; mNextView=&quot; + mNextView);</div><div class="line">    if (mView != mNextView) &#123;</div><div class="line">        handleHide();</div><div class="line">        mView = mNextView;</div><div class="line">        // ...</div><div class="line">        // 展示使用的是 WindowManager</div><div class="line">        mWM = (WindowManager)context.getSystemService(Context.WINDOW_SERVICE);</div><div class="line">        </div><div class="line">        // 下面配置的是位置参数</div><div class="line">        final Configuration config = mView.getContext().getResources().getConfiguration();</div><div class="line">        final int gravity = Gravity.getAbsoluteGravity(mGravity, config.getLayoutDirection());</div><div class="line">        mParams.gravity = gravity;</div><div class="line">        if ((gravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) == Gravity.FILL_HORIZONTAL) &#123;</div><div class="line">            mParams.horizontalWeight = 1.0f;</div><div class="line">        &#125;</div><div class="line">        if ((gravity &amp; Gravity.VERTICAL_GRAVITY_MASK) == Gravity.FILL_VERTICAL) &#123;</div><div class="line">            mParams.verticalWeight = 1.0f;</div><div class="line">        &#125;</div><div class="line">        mParams.x = mX;</div><div class="line">        mParams.y = mY;</div><div class="line">        mParams.verticalMargin = mVerticalMargin;</div><div class="line">        mParams.horizontalMargin = mHorizontalMargin;</div><div class="line">        mParams.packageName = packageName;</div><div class="line">        mParams.hideTimeoutMilliseconds = mDuration ==</div><div class="line">            Toast.LENGTH_LONG ? LONG_DURATION_TIMEOUT : SHORT_DURATION_TIMEOUT;</div><div class="line">        mParams.token = windowToken;</div><div class="line">        if (mView.getParent() != null) &#123;</div><div class="line">            if (localLOGV) Log.v(TAG, &quot;REMOVE! &quot; + mView + &quot; in &quot; + this);</div><div class="line">            mWM.removeView(mView);</div><div class="line">        &#125;</div><div class="line">        if (localLOGV) Log.v(TAG, &quot;ADD! &quot; + mView + &quot; in &quot; + this);</div><div class="line">        // 展示 Toast, 由此也可以看出，Toast 是被添加在 Window 下的</div><div class="line">        mWM.addView(mView, mParams);</div><div class="line">        trySendAccessibilityEvent();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Toast 是先调用 makeText 创建要展示的 view, 调用 show 方法时内部跨进程通知 NotificationManagerService, 再通知到 TN 执行 show 方法，最终通过 handler 添加到 Window 下。<br>再看下最开始的思考，</p>
<ol>
<li><p>makeText 会 new Toast, Toast 构造方法里创建 TN 对象，TN 有一个成员变量 mHandler, 在创建 Handler 时需要该线程有 Looper 对象，主线程的 ActivityThread 的 main() 方法有创建 Looper 对象，但子线程并没有 Looper 对象，所以会抛异常。</p>
</li>
<li><p>如果在子线程调 Looper.prepare(), 会是在主线程展示的 Toast 吗，看上面的代码很明显不是，因为 Toast, TN 都是在子线程创建的，所以 mHandler 也是在子线程创建的，处理消息时的 Looper 也是子线程创建的，所以展示也是在子线程的。</p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hexiaosa.com/2018/08/12/ThreadPool/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hexiaosa">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexiaosa">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/12/ThreadPool/" itemprop="url">线程池简介和源码分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-12T14:39:43+08:00">
                2018-08-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="线程池的介绍和使用"><a href="#线程池的介绍和使用" class="headerlink" title="线程池的介绍和使用"></a>线程池的介绍和使用</h3><p>线程池的优点：提高性能，提高线程的利用率，可控制线程的最大并发数，方便线程管理。<br>线程池的核心类是 ThreadPoolExecutor, 可通过 Executors 中的几个方法创建线程池，分别是：</p>
<ol>
<li><p>CachedThreadPool<br>核心线程数为 0, 线程数量无上限</p>
</li>
<li><p>FixedThreadPool<br>核心线程数由使用者自己指定，无非核心线程，线程空闲时不会被回收，除非线程池被关闭</p>
</li>
<li><p>ScheduledThreadPool<br>指定数量的核心线程数，线程数无上限，非核心线程空闲时会被回收</p>
</li>
<li><p>SingleThreadExecutor<br>核心线程为 1, 无非核心线程，线程空闲时不会被回收。意义在于使得任务都放在同一线程处理，不必考虑线程同步问题。</p>
</li>
</ol>
<h3 id="线程池构造方法参数介绍"><a href="#线程池构造方法参数介绍" class="headerlink" title="线程池构造方法参数介绍"></a>线程池构造方法参数介绍</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public ThreadPoolExecutor(int corePoolSize,</div><div class="line">                          int maximumPoolSize,</div><div class="line">                          long keepAliveTime,</div><div class="line">                          TimeUnit unit,</div><div class="line">                          BlockingQueue&lt;Runnable&gt; workQueue,</div><div class="line">                          ThreadFactory threadFactory,</div><div class="line">                          RejectedExecutionHandler handler) &#123;</div><div class="line">    // ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面是线程池的构造方法，分析一下创建线程池的七个参数的含义：</p>
<ol>
<li><p>corePoolSize<br>核心线程数，在空闲时不会被回收，在线程池关闭后才会被回收（allowCoreThreadTimeOut 被设为 true 除外）。</p>
</li>
<li><p>maximunPoolSize<br>线程数上限，可利用该参数控制线程最大并发数，非核心线程在空闲时会被回收。</p>
</li>
<li><p>keepAliveTime<br>非核心线程的闲置时长，超过这个时长就会被回收，当 allowCoreThreadTimeOut 被设为 true 后，这个时长也同样作用于核心线程。</p>
</li>
<li><p>unit<br>keepAliveTime 的时间单位。</p>
</li>
<li><p>workQueue<br>保存核心线程的队列。</p>
</li>
<li><p>threadFactory<br>用于创建新的线程。</p>
</li>
<li><p>handler<br>如果执行（添加）任务失败，则会执行 handler.rejectedExecution(command, this); 这个方法在需要处理拒绝后的操作时由我们自己实现来处理。</p>
</li>
</ol>
<h3 id="线程池原理"><a href="#线程池原理" class="headerlink" title="线程池原理"></a>线程池原理</h3><p>线程池创建过后执行会调用 ThreadPoolExecutor 的 execute(Runnable) 方法来执行线程，步骤如下：</p>
<ol>
<li><p>如果当前线程数小于核心线程，则创建新的线程保存到核心线程并执行；</p>
</li>
<li><p>否则，核心线程数已满，则插入到任务队列中等待</p>
</li>
<li><p>插入到任务队列失败，则启动非核心线程来执行</p>
</li>
<li><p>启动非核心线程失败，则 reject.</p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Hexiaosa</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">32</span>
                  <span class="site-state-item-name">Artikel</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hexiaosa</span>

  
</div>


  <div class="powered-by">Erstellt mit  <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
