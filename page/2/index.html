<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Hexiaosa">
<meta property="og:url" content="http://hexiaosa.com/page/2/index.html">
<meta property="og:site_name" content="Hexiaosa">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexiaosa">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://hexiaosa.com/page/2/"/>





  <title>Hexiaosa</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexiaosa</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Startseite
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archiv
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hexiaosa.com/2018/08/21/ReentrantLock-theory/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hexiaosa">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexiaosa">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/21/ReentrantLock-theory/" itemprop="url">并发编程 —— ReentrantLock 原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-21T18:29:48+08:00">
                2018-08-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>ReentrantReadWriteLock 是通过加锁来保证线程安全的，它是 Java 源码中内置的加锁的类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ReentrantReadWriteLock lock = new ReentrantReadWriteLock();</div><div class="line">try &#123;</div><div class="line">    lock.writeLock().lock();</div><div class="line">&#125; finally &#123;</div><div class="line">    lock.writeLock().unlock();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么它内部是通过什么方式来实现加锁的呢，通过以下源码中的注释便可清楚。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public ReentrantReadWriteLock() &#123;</div><div class="line">    this(false); // 默认是 false</div><div class="line">&#125;</div><div class="line">public ReentrantReadWriteLock(boolean fair) &#123;</div><div class="line">    // 默认是不公平锁</div><div class="line">    sync = fair ? new FairSync() : new NonfairSync();</div><div class="line">    readerLock = new ReadLock(this);</div><div class="line">    writerLock = new WriteLock(this);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>先来看 WriteLock 的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">// WriteLock</div><div class="line">public void lock() &#123;</div><div class="line">    sync.acquire(1);</div><div class="line">&#125;</div><div class="line">// Sync继承自 AbstractQueuedSynchronizer, acquire 方法是在 AbstractQueuedSynchronizer 里实现的</div><div class="line">public final void acquire(int arg) &#123;</div><div class="line">    // 主要控制同步的逻辑在 tryAcquire</div><div class="line">    if (!tryAcquire(arg) &amp;&amp;</div><div class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</div><div class="line">        selfInterrupt(); // 如果没有获取到锁，当前线程中断</div><div class="line">&#125;</div><div class="line">// Sync 类中 tryAcquire 方法的实现</div><div class="line">protected final boolean tryAcquire(int acquires) &#123;</div><div class="line">    Thread current = Thread.currentThread();</div><div class="line">    int c = getState(); // 持有该锁的数量</div><div class="line">    int w = exclusiveCount(c);</div><div class="line">    if (c != 0) &#123;</div><div class="line">        // 已经有持有该锁的</div><div class="line">        if (w == 0 || current != getExclusiveOwnerThread())</div><div class="line">            return false; // 持有锁的线程不是当前线程</div><div class="line">        if (w + exclusiveCount(acquires) &gt; MAX_COUNT)</div><div class="line">            throw new Error(&quot;Maximum lock count exceeded&quot;);</div><div class="line">        // 同一线程，如果是嵌套的，这里就是可重入锁的原理所在</div><div class="line">        setState(c + acquires);</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line">    // 还没有持有该锁的，如果写数量失败了，就返回 false</div><div class="line">    if (writerShouldBlock() ||</div><div class="line">        !compareAndSetState(c, c + acquires))</div><div class="line">        return false;</div><div class="line">    // 设置持有锁的线程是当前线程</div><div class="line">    setExclusiveOwnerThread(current);</div><div class="line">    return true;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>到这里加锁主要逻辑就结束了，那么解锁的呢？接着往下看，解锁跟加锁的过程比较类似<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">// WriteLock</div><div class="line">public void unlock() &#123;</div><div class="line">    sync.release(1);</div><div class="line">&#125;</div><div class="line">// Sync继承自 AbstractQueuedSynchronizer, acquire 方法是在 AbstractQueuedSynchronizer 里实现的</div><div class="line">public final boolean release(int arg) &#123;</div><div class="line">    // 解锁的主要逻辑在 tryRelease</div><div class="line">    if (tryRelease(arg)) &#123;</div><div class="line">        // ...</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line">    return false;</div><div class="line">&#125;</div><div class="line">// Sync 类的 tryRelease 实现</div><div class="line">protected final boolean tryRelease(int releases) &#123;</div><div class="line">    // ...</div><div class="line">    int nextc = getState() - releases; // 剩余的锁的数量</div><div class="line">    boolean free = exclusiveCount(nextc) == 0; // 是否已经没有锁</div><div class="line">    if (free)</div><div class="line">        setExclusiveOwnerThread(null); // 如果已经没有锁，则持有线程置为 null</div><div class="line">    setState(nextc); // 设置剩余锁的数量</div><div class="line">    return free; // 返回是否已经不再持有锁</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>总结：ReentrantLock 就是通过设置当前持有锁的线程和持有锁的数量，加锁时候通过判断这些来决定是否能获取锁，如果暂时不能获取锁，则线程中断。解锁过程是修改相应的持有锁线程和持有锁数量。</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hexiaosa.com/2018/08/15/view-onDraw-LineChart/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hexiaosa">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexiaosa">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/15/view-onDraw-LineChart/" itemprop="url">自定义 View ———— 折线图（重写 onDraw方法）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-15T20:55:08+08:00">
                2018-08-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>实现一个如下效果的折线图<br><img src="/image/line_result.jpg" alt="line_result"></p>
<p>这样的效果实现的方式很容易想到的就是重写 onDraw 方法，给定一组 float 值，分别画点、线，那么下面有颜色的阴影部分是用什么画呢，就用到了 Path, 一个点一个点相连成一个封闭的图形，便可画出这个图形。如果先画点，再画阴影部分，是会把点遮住一部分的，所以实现的时候先画完了阴影部分，再画线和点。不过这样子在 onDraw 方法里就有两个 for 循环，如果有好的办法欢迎提出。（邮箱：hexiaosa91@163.com）<br>下面直接贴出 View 的整个代码，代码不多</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @author hexiaosa</div><div class="line"> * @date 2018/8/15</div><div class="line"> */</div><div class="line"></div><div class="line">public class CustomLineChart extends View &#123;</div><div class="line"></div><div class="line">    private int width; // 宽</div><div class="line">    private int height; // 高</div><div class="line">    private int pointNum; // 折点个数</div><div class="line">    private int lineColor; // 折线颜色</div><div class="line">    private int shadowColor; // 阴影颜色</div><div class="line">    private float[] percents; // 百分比，可以理解为任务完成百分比</div><div class="line">    private int itemWidth;</div><div class="line">    private Path path; // 避免在 onDraw 方法内创建多个对象，所以在这里声明一个成员变量</div><div class="line"></div><div class="line">    public CustomLineChart(Context context) &#123;</div><div class="line">        this(context, null);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public CustomLineChart(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        this(context, attrs, 0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public CustomLineChart(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123;</div><div class="line">        super(context, attrs, defStyleAttr);</div><div class="line"></div><div class="line">        // 线颜色，阴影颜色，折点个数</div><div class="line">        TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.CustomLineChart);</div><div class="line">        lineColor = typedArray.getColor(R.styleable.CustomLineChart_lineColor, Color.BLACK);</div><div class="line">        shadowColor = typedArray.getColor(R.styleable.CustomLineChart_shadowColor, Color.BLACK);</div><div class="line">        pointNum = typedArray.getInteger(R.styleable.CustomLineChart_pointNum, 0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        if (pointNum == 0) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        if (percents == null || percents.length != pointNum) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        if (width == 0) &#123;</div><div class="line">            width = getMeasuredWidth();</div><div class="line">        &#125;</div><div class="line">        if (height == 0) &#123;</div><div class="line">            height = getMeasuredHeight();</div><div class="line">        &#125;</div><div class="line">        if (path == null) &#123;</div><div class="line">            path = new Path();</div><div class="line">        &#125;</div><div class="line">        itemWidth = width/(pointNum-1);</div><div class="line">        Paint paint = new Paint();</div><div class="line">        paint.setStrokeWidth(5);</div><div class="line">        // 阴影部分使用 Path 连接成一个封闭图形</div><div class="line">        path.reset();</div><div class="line">        path.moveTo(0, height);</div><div class="line">        path.lineTo(0, height*(1-percents[0]));</div><div class="line">        for (int i = 1; i &lt; percents.length; i++) &#123;</div><div class="line">            // 连接阴影</div><div class="line">            path.lineTo(itemWidth*i, height*(1-percents[i]));</div><div class="line">        &#125;</div><div class="line">        path.lineTo(width, height);</div><div class="line">        path.lineTo(0, height);</div><div class="line">        paint.setColor(shadowColor);</div><div class="line">        // 画阴影</div><div class="line">        canvas.drawPath(path, paint);</div><div class="line">        path.close();</div><div class="line"></div><div class="line">        paint.setColor(lineColor);</div><div class="line">        canvas.drawCircle(0, height*(1-percents[0]), 10, paint);</div><div class="line">        for (int i = 1; i &lt; percents.length; i++) &#123;</div><div class="line">            // 画线</div><div class="line">            canvas.drawLine(itemWidth*(i-1), height*(1-percents[i-1]), itemWidth*i, height*(1-percents[i]), paint);</div><div class="line">            // 画点</div><div class="line">            canvas.drawCircle(itemWidth*i, height*(1-percents[i]), 10, paint);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        canvas.save();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public void setPercents(float[] percents) &#123;</div><div class="line">        this.percents = percents;</div><div class="line">        invalidate();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setLineColor(int lineColor) &#123;</div><div class="line">        this.lineColor = lineColor;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setShadowColor(int shadowColor) &#123;</div><div class="line">        this.shadowColor = shadowColor;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setPointNum(int pointNum) &#123;</div><div class="line">        this.pointNum = pointNum;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// attr.xml</div><div class="line">    &lt;declare-styleable name=&quot;CustomLineChart&quot;&gt;</div><div class="line">        &lt;attr name=&quot;lineColor&quot; format=&quot;color&quot;/&gt;</div><div class="line">        &lt;attr name=&quot;shadowColor&quot; format=&quot;color&quot;/&gt;</div><div class="line">        &lt;attr name=&quot;pointNum&quot; format=&quot;integer&quot;/&gt;</div><div class="line">    &lt;/declare-styleable&gt;</div></pre></td></tr></table></figure>
<p>使用示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">CustomLineChart clc = (CustomLineChart) findViewById(R.id.clc);</div><div class="line">// 必须设置，还有 pointNum 在布局或代码设置至少有一个地方设置，且 pointNum 需等于 percents.length</div><div class="line">clc.setPercents(new float[]&#123;0.5f, 0.3f, 0.4f, 0.7f, 0.1f, 0.2f, 0.6f, 0.8f, 0.9f, 1f&#125;);</div></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hexiaosa.com/2018/08/15/retrofit/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hexiaosa">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexiaosa">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/15/retrofit/" itemprop="url">Retrofit 源码分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-15T20:47:33+08:00">
                2018-08-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Retrofit-使用例子"><a href="#Retrofit-使用例子" class="headerlink" title="Retrofit 使用例子"></a>Retrofit 使用例子</h3><p>下面只展示了异步请求示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">Retrofit retrofit = new Retrofit.Builder()</div><div class="line">        .baseUrl(&quot;https://api.github.com&quot;)</div><div class="line">        .build();</div><div class="line"></div><div class="line">GitHubService service = retrofit.create(GitHubService.class);</div><div class="line">service.search().enqueue(new retrofit2.Callback&lt;String&gt;() &#123;</div><div class="line">    @Override</div><div class="line">    public void onResponse(retrofit2.Call&lt;String&gt; call, retrofit2.Response&lt;String&gt; response) &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onFailure(retrofit2.Call&lt;String&gt; call, Throwable t) &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>Retrofit 中使用了 OkHttp, 分析到后面就可以看到。<br>先来看创建 Retrofit 吧：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public Retrofit build() &#123;</div><div class="line">	// ...</div><div class="line">	okhttp3.Call.Factory callFactory = this.callFactory;</div><div class="line">	if (callFactory == null) &#123;</div><div class="line">		// 创建 callFactory 对象，也就是 Retrofit 的 callFactory.</div><div class="line">		callFactory = new OkHttpClient();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	Executor callbackExecutor = this.callbackExecutor;</div><div class="line">	if (callbackExecutor == null) &#123;</div><div class="line">		// 创建 callbackExecutor 对象，platform 是 Android 的实例，其 defaultCallbackExecutor 方法返回的是 ExecutorCallAdapterFactory 对象</div><div class="line">		callbackExecutor = platform.defaultCallbackExecutor();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	List&lt;CallAdapter.Factory&gt; callAdapterFactories = new ArrayList&lt;&gt;(this.callAdapterFactories);</div><div class="line">	// 把上面创建的 callbackExecutor 添加到 callAdapterFactories 中</div><div class="line">	callAdapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor));</div><div class="line">	// ...</div><div class="line">	return new Retrofit(callFactory, baseUrl, unmodifiableList(converterFactories),</div><div class="line">	  unmodifiableList(callAdapterFactories), callbackExecutor, validateEagerly);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面代码主要创建了 retrofit 对象，还创建了这几个稍等分析会用到的对象，callFactory、callbackExecutor.</p>
<p>下面接着往下看 retrofit.create 方法，这里使用了代理模式，create 创建的 GitHubService 对象可以调用 search 方法，search 方法的执行就在代理的实现里面，这个就一起分析了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">public &lt;T&gt; T create(final Class&lt;T&gt; service) &#123;</div><div class="line">	Utils.validateServiceInterface(service);</div><div class="line">	if (validateEagerly) &#123;</div><div class="line">	    eagerlyValidateMethods(service);</div><div class="line">	&#125;</div><div class="line">	// 代理实现, service.search 走的就是这里的 invoke 方法</div><div class="line">	return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] &#123; service &#125;,</div><div class="line">	    new InvocationHandler() &#123;</div><div class="line">			private final Platform platform = Platform.get();</div><div class="line"></div><div class="line">			@Override public Object invoke(Object proxy, Method method, @Nullable Object[] args)</div><div class="line">			  throws Throwable &#123;</div><div class="line">			// If the method is a method from Object then defer to normal invocation.</div><div class="line">				if (method.getDeclaringClass() == Object.class) &#123;</div><div class="line">				  return method.invoke(this, args);</div><div class="line">				&#125;</div><div class="line">				if (platform.isDefaultMethod(method)) &#123;</div><div class="line">				  return platform.invokeDefaultMethod(method, service, proxy, args);</div><div class="line">				&#125;</div><div class="line">				// 这里是主要内容</div><div class="line">				/* 封装 ServiceMethod 对象，创建 ServiceMethod 对象时创建了 callAdapter 实例，callAdapter 是 retrofit.callAdapter(returnType, annotations), 再往里看就是 retrofit 的成员变量 callAdapterFactories.get(i).get(returnType, annotations, this), callAdapterFactories 是在创建 retrofit 时，里面存的是 ExecutorCallAdapterFactory 对象</div><div class="line">					    return new CallAdapter&lt;Object, Call&lt;?&gt;&gt;() &#123;</div><div class="line">					      @Override public Type responseType() &#123;</div><div class="line">					        return responseType;</div><div class="line">					      &#125;</div><div class="line"></div><div class="line">					      @Override public Call&lt;Object&gt; adapt(Call&lt;Object&gt; call) &#123;</div><div class="line">					        return new ExecutorCallbackCall&lt;&gt;(callbackExecutor, call);</div><div class="line">					      &#125;</div><div class="line">					    &#125;;</div><div class="line">			    这就是 ServiceMethod 的 callAdapter 对象</div><div class="line">				 */</div><div class="line">				ServiceMethod&lt;Object, Object&gt; serviceMethod =</div><div class="line">				    (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method);</div><div class="line">				// 创建 OkHttpCall</div><div class="line">				OkHttpCall&lt;Object&gt; okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args);</div><div class="line">				// 其中 callAdapter 在封装 ServiceMethod 对象时创建的，执行的 callAdapter.adapt(call) 返回的就是 new ExecutorCallbackCall&lt;&gt;(callbackExecutor, call)</div><div class="line">				return serviceMethod.adapt(okHttpCall);</div><div class="line">			&#125;</div><div class="line">	    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到 service.search 返回的是 ExecutorCallbackCall 对象，它的成员变量 delegate 是上面创建的 OkHttpCall 对象，那么接下来的 enqueue 方法就是 ExecutorCallbackCall 的 enqueue 了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div></pre></td><td class="code"><pre><div class="line">    @Override public void enqueue(final Callback&lt;T&gt; callback) &#123;</div><div class="line">		checkNotNull(callback, &quot;callback == null&quot;);</div><div class="line">        // 主要看下面这一点，delegata.enqueue, delegate 是 OkHttpCall 对象，那接着看下一个 OkHttpCall 的 enqueue 方法把</div><div class="line">		delegate.enqueue(new Callback&lt;T&gt;() &#123;</div><div class="line">		@Override public void onResponse(Call&lt;T&gt; call, final Response&lt;T&gt; response) &#123;</div><div class="line">		  callbackExecutor.execute(new Runnable() &#123;</div><div class="line">		    @Override public void run() &#123;</div><div class="line">				if (delegate.isCanceled()) &#123;</div><div class="line">					// Emulate OkHttp&apos;s behavior of throwing/delivering an IOException on cancellation.</div><div class="line">					callback.onFailure(ExecutorCallbackCall.this, new IOException(&quot;Canceled&quot;));</div><div class="line">				&#125; else &#123;</div><div class="line">					callback.onResponse(ExecutorCallbackCall.this, response);</div><div class="line">				&#125;</div><div class="line">		    &#125;</div><div class="line">		  &#125;);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		@Override public void onFailure(Call&lt;T&gt; call, final Throwable t) &#123;</div><div class="line">			callbackExecutor.execute(new Runnable() &#123;</div><div class="line">				@Override public void run() &#123;</div><div class="line">				    callback.onFailure(ExecutorCallbackCall.this, t);</div><div class="line">				&#125;</div><div class="line">			&#125;);</div><div class="line">		&#125;</div><div class="line">		&#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">@Override public void enqueue(final Callback&lt;T&gt; callback) &#123;</div><div class="line">	checkNotNull(callback, &quot;callback == null&quot;);</div><div class="line"></div><div class="line">	okhttp3.Call call;</div><div class="line">	Throwable failure;</div><div class="line"></div><div class="line">	synchronized (this) &#123;</div><div class="line">		if (executed) throw new IllegalStateException(&quot;Already executed.&quot;);</div><div class="line">		executed = true;</div><div class="line"></div><div class="line">		call = rawCall;</div><div class="line">		failure = creationFailure;</div><div class="line">		if (call == null &amp;&amp; failure == null) &#123;</div><div class="line">			try &#123;</div><div class="line">				// 创建 call 对象，serviceMethod.toCall -&gt; callFactory.newCall(callFactory 就是在最开始创建 retrofit 对象的 OkHttpClient 实例) -&gt; okHttpClient.newCall(这里使用的就是 OkHttp 框架的了) -&gt; RealCall</div><div class="line">			    call = rawCall = createRawCall();</div><div class="line">			&#125; catch (Throwable t) &#123;</div><div class="line">			    throwIfFatal(t);</div><div class="line">			    failure = creationFailure = t;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	if (failure != null) &#123;</div><div class="line">		callback.onFailure(this, failure);</div><div class="line">		return;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	if (canceled) &#123;</div><div class="line">		call.cancel();</div><div class="line">	&#125;</div><div class="line">	// call 是 RealCall 对象，接下来的 enqueue 方法跟分析 OkHttp 的就一样了</div><div class="line">	call.enqueue(new okhttp3.Callback() &#123;</div><div class="line">		@Override public void onResponse(okhttp3.Call call, okhttp3.Response rawResponse) &#123;</div><div class="line">			Response&lt;T&gt; response;</div><div class="line">			try &#123;</div><div class="line">			    response = parseResponse(rawResponse);</div><div class="line">			&#125; catch (Throwable e) &#123;</div><div class="line">			    callFailure(e);</div><div class="line">			    return;</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			try &#123;</div><div class="line">			    callback.onResponse(OkHttpCall.this, response);</div><div class="line">			&#125; catch (Throwable t) &#123;</div><div class="line">			    t.printStackTrace();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		@Override public void onFailure(okhttp3.Call call, IOException e) &#123;</div><div class="line">			callFailure(e);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		private void callFailure(Throwable e) &#123;</div><div class="line">			try &#123;</div><div class="line">			    callback.onFailure(OkHttpCall.this, e);</div><div class="line">			&#125; catch (Throwable t) &#123;</div><div class="line">			    t.printStackTrace();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hexiaosa.com/2018/08/14/OkHttp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hexiaosa">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexiaosa">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/14/OkHttp/" itemprop="url">OkHttp 源码分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-14T21:16:41+08:00">
                2018-08-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="OkHttp-使用代码实例"><a href="#OkHttp-使用代码实例" class="headerlink" title="OkHttp 使用代码实例"></a>OkHttp 使用代码实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">private static final MediaType JSON</div><div class="line">        = MediaType.parse(&quot;application/json; charset=utf-8&quot;);</div><div class="line">OkHttpClient client = new OkHttpClient();</div><div class="line"></div><div class="line">String post(String url, String json) throws IOException &#123;</div><div class="line">    RequestBody body = RequestBody.create(JSON, json);</div><div class="line">    Request request = new Request.Builder()</div><div class="line">            .url(url)</div><div class="line">            .post(body)</div><div class="line">            .build();</div><div class="line">    // 同步调用</div><div class="line">    Response response = client.newCall(request).execute();</div><div class="line">    // 异步调用</div><div class="line">    client.newCall(request).enqueue(new Callback() &#123;</div><div class="line">        @Override</div><div class="line">        public void onFailure(Call call, IOException e) &#123;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void onResponse(Call call, Response response) throws IOException &#123;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    return response.body().string();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>先来看 new OkHttpClient()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">public OkHttpClient() &#123;</div><div class="line">this(new Builder());</div><div class="line">&#125;</div><div class="line"></div><div class="line">public Builder() &#123;</div><div class="line">    // 创建了 Dispatcher 对象</div><div class="line">	dispatcher = new Dispatcher();</div><div class="line">	protocols = DEFAULT_PROTOCOLS;</div><div class="line">	connectionSpecs = DEFAULT_CONNECTION_SPECS;</div><div class="line">	eventListenerFactory = EventListener.factory(EventListener.NONE);</div><div class="line">	proxySelector = ProxySelector.getDefault();</div><div class="line">	cookieJar = CookieJar.NO_COOKIES;</div><div class="line">	socketFactory = SocketFactory.getDefault();</div><div class="line">	hostnameVerifier = OkHostnameVerifier.INSTANCE;</div><div class="line">	certificatePinner = CertificatePinner.DEFAULT;</div><div class="line">	proxyAuthenticator = Authenticator.NONE;</div><div class="line">	authenticator = Authenticator.NONE;</div><div class="line">	connectionPool = new ConnectionPool();</div><div class="line">	dns = Dns.SYSTEM;</div><div class="line">	followSslRedirects = true;</div><div class="line">	followRedirects = true;</div><div class="line">	retryOnConnectionFailure = true;</div><div class="line">	connectTimeout = 10_000;</div><div class="line">	readTimeout = 10_000;</div><div class="line">	writeTimeout = 10_000;</div><div class="line">	pingInterval = 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后 clien.newCall(request) 创建了 RealCall 对象，这也是 OkHttp 中一个重要的类，先来分析异步执行的源码吧，因为同步执行跟异步的后半段没什么区别了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@Override public void enqueue(Callback responseCallback) &#123;</div><div class="line">	synchronized (this) &#123;</div><div class="line">		if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);</div><div class="line">		executed = true;</div><div class="line">	&#125;</div><div class="line">	captureCallStackTrace();</div><div class="line">	eventListener.callStart(this);</div><div class="line">	// 执行 dispatcher 的 enqueue 方法，dispatcher 是在创建 HttpClient 对象时 new 的。注意这里传过去是的 new AsyncCall(responseCallback)</div><div class="line">	client.dispatcher().enqueue(new AsyncCall(responseCallback));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>AsyncCall 是实现了 NamedRunnable<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public abstract class NamedRunnable implements Runnable &#123;</div><div class="line">	// ...</div><div class="line">	@Override public final void run() &#123;</div><div class="line">		// ...</div><div class="line">		try &#123;</div><div class="line">			execute();</div><div class="line">		&#125; finally &#123;</div><div class="line">		    Thread.currentThread().setName(oldName);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	protected abstract void execute();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到就是实现的 Runnable 接口，如果在一个线程里执行，执行的就是 execute 方法。再接着看 dispatcher  的 enqueue 方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">synchronized void enqueue(AsyncCall call) &#123;</div><div class="line">	if (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</div><div class="line">		// 添加到执行队列</div><div class="line">	    runningAsyncCalls.add(call);</div><div class="line">	    // 在子线程执行方法，executorService 就是创建了线程池。</div><div class="line">	    executorService().execute(call);</div><div class="line">	&#125; else &#123;</div><div class="line">		// 添加到等待队列</div><div class="line">	    readyAsyncCalls.add(call);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>AsyncCall 执行的是 execute 方法，下面接着看这里<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">@Override protected void execute() &#123;</div><div class="line">	boolean signalledCallback = false;</div><div class="line">	try &#123;</div><div class="line">		// 责任链模式，链式调用的地方</div><div class="line">		Response response = getResponseWithInterceptorChain();</div><div class="line">		if (retryAndFollowUpInterceptor.isCanceled()) &#123;</div><div class="line">			signalledCallback = true;</div><div class="line">			// 返回回调失败</div><div class="line">			responseCallback.onFailure(RealCall.this, new IOException(&quot;Canceled&quot;));</div><div class="line">		&#125; else &#123;</div><div class="line">			signalledCallback = true;</div><div class="line">			// 返回回调成功</div><div class="line">			responseCallback.onResponse(RealCall.this, response);</div><div class="line">		&#125;</div><div class="line">	&#125; catch (IOException e) &#123;</div><div class="line">		if (signalledCallback) &#123;</div><div class="line">		    // Do not signal the callback twice!</div><div class="line">		    Platform.get().log(INFO, &quot;Callback failure for &quot; + toLoggableString(), e);</div><div class="line">		&#125; else &#123;</div><div class="line">		    eventListener.callFailed(RealCall.this, e);</div><div class="line">		    // 返回回调失败</div><div class="line">		    responseCallback.onFailure(RealCall.this, e);</div><div class="line">		&#125;</div><div class="line">	&#125; finally &#123;</div><div class="line">		// 从 dispatcher 的运行队列中清除该 Runnable</div><div class="line">		client.dispatcher().finished(this);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Response getResponseWithInterceptorChain() throws IOException &#123;</div><div class="line">	// Build a full stack of interceptors.</div><div class="line">	List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;();</div><div class="line">	// 添加自己定义的 interceptor</div><div class="line">	interceptors.addAll(client.interceptors());</div><div class="line">	// 重试</div><div class="line">	interceptors.add(retryAndFollowUpInterceptor);</div><div class="line">	// 转换</div><div class="line">	interceptors.add(new BridgeInterceptor(client.cookieJar()));</div><div class="line">	// 缓存</div><div class="line">	interceptors.add(new CacheInterceptor(client.internalCache()));</div><div class="line">	// 连接</div><div class="line">	interceptors.add(new ConnectInterceptor(client));</div><div class="line">	if (!forWebSocket) &#123;</div><div class="line">	    interceptors.addAll(client.networkInterceptors());</div><div class="line">	&#125;</div><div class="line">	// 请求服务器</div><div class="line">	interceptors.add(new CallServerInterceptor(forWebSocket));</div><div class="line"></div><div class="line">    // 开始链式调用</div><div class="line">	Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0,</div><div class="line">	    originalRequest, this, eventListener, client.connectTimeoutMillis(),</div><div class="line">	    client.readTimeoutMillis(), client.writeTimeoutMillis());</div><div class="line">	return chain.proceed(originalRequest);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>来一个链式调用的例子吧，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">// 实际执行</div><div class="line">public static void main(String[] args) &#123;</div><div class="line">	List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;();</div><div class="line">	interceptors.add(new Interceptor1());</div><div class="line">	interceptors.add(new Interceptor2());</div><div class="line">	InterceptorChain chain = new InterceptorChain(interceptors, 0);</div><div class="line">	chain.proceed();</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 执行链</div><div class="line">public class InterceptorChain &#123;</div><div class="line">	</div><div class="line">	private List&lt;Interceptor&gt; interceptors;</div><div class="line">	private int index;</div><div class="line">	</div><div class="line">	public InterceptorChain(List&lt;Interceptor&gt; interceptors, int index) &#123;</div><div class="line">		this.interceptors = interceptors;</div><div class="line">		this.index = index;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void proceed() &#123;</div><div class="line">		if (index &gt;= interceptors.size()) &#123;</div><div class="line">			System.out.println(&quot;调用完&quot;);</div><div class="line">			return;</div><div class="line">		&#125;</div><div class="line">		InterceptorChain chain = new InterceptorChain(interceptors, index+1);</div><div class="line">		Interceptor interceptor = interceptors.get(index);</div><div class="line">		interceptor.proceed(chain);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Interceptor</div><div class="line">public interface Interceptor &#123;</div><div class="line">	String proceed(InterceptorChain chain);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Interceptor1 implements Interceptor &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public String proceed(InterceptorChain chain) &#123;</div><div class="line">		System.out.println(&quot;Interceptor1 start&quot;);</div><div class="line">		chain.proceed();</div><div class="line">		System.out.println(&quot;Interceptor1 end&quot;);</div><div class="line">		return &quot;Interceptor1&quot;;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Interceptor2 implements Interceptor &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public String proceed(InterceptorChain chain) &#123;</div><div class="line">		System.out.println(&quot;Interceptor2 start&quot;);</div><div class="line">		chain.proceed();</div><div class="line">		System.out.println(&quot;Interceptor2 end&quot;);</div><div class="line">		return &quot;Interceptor2&quot;;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最终的执行结果是：<br>Interceptor1 start<br>Interceptor2 start<br>调用完<br>Interceptor2 end<br>Interceptor1 end</p>
<p>可以看到 1 先执行，在 1 里面调 2 的执行，2 执行完的返回结果，1 可以再进行处理。<br>来一张图解释下吧<br><img src="/image/interceptor_chain.jpg" alt="interceptor_chain"></p>
<p>OkHttp 的调用过程用下面的图来简介一下<br><img src="/image/OkHttp_chain.png" alt="OkHttp_chain"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hexiaosa.com/2018/08/14/toast/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hexiaosa">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexiaosa">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/14/toast/" itemprop="url">Toast 源码分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-14T21:15:28+08:00">
                2018-08-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>在分析源码之前有两个问题</p>
<ol>
<li><p>子线程直接使用 Toast 时会抛出异常 “Can’t create handler inside thread that has not called Looper.prepare()”, 在 Toast 类里搜 “Looper” 并搜不到。是哪里抛出的这个异常呢？</p>
</li>
<li><p>在子线程中这样使用 Toast:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Looper.prepare();</div><div class="line">Toast.makeText(getApplicationContext(), &quot;test toast&quot;, Toast.LENGTH_SHORT).show();</div><div class="line">Looper.loop();</div></pre></td></tr></table></figure>
</li>
</ol>
<p>像上面这种调用是在主线程显示 Toast 吗</p>
<h3 id="Toast-源码分析"><a href="#Toast-源码分析" class="headerlink" title="Toast 源码分析"></a>Toast 源码分析</h3><p>先看 Toast 的 makeText 和 show 方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">public static Toast makeText(Context context, CharSequence text, @Duration int duration) &#123;</div><div class="line">	// 创建 TN(Toast 的内置对象)，用于展示 Toast 的主要类</div><div class="line">    Toast result = new Toast(context);</div><div class="line"></div><div class="line">    // 加载 Toast 的展示内容</div><div class="line">    LayoutInflater inflate = (LayoutInflater)</div><div class="line">            context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);</div><div class="line">    View v = inflate.inflate(com.android.internal.R.layout.transient_notification, null);</div><div class="line">    TextView tv = (TextView)v.findViewById(com.android.internal.R.id.message);</div><div class="line">    tv.setText(text);</div><div class="line">    </div><div class="line">    // 赋值一些属性</div><div class="line">    result.mNextView = v;</div><div class="line">    result.mDuration = duration;</div><div class="line"></div><div class="line">    return result;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public void show() &#123;</div><div class="line">	// 校验显示内容</div><div class="line">    if (mNextView == null) &#123;</div><div class="line">        throw new RuntimeException(&quot;setView must have been called&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    INotificationManager service = getService(); // NotificationManagerService 的成员变量 mService 是 INotificationManager.Stub 的实现类</div><div class="line">    String pkg = mContext.getOpPackageName();</div><div class="line">    TN tn = mTN;</div><div class="line">    // 展示内容属性赋值给 tn 的属性</div><div class="line">    tn.mNextView = mNextView;</div><div class="line"></div><div class="line">    try &#123;</div><div class="line">    	// 调用 NotificationManagerService 中 mService 的 enqueueToast 方法</div><div class="line">        service.enqueueToast(pkg, tn, mDuration);</div><div class="line">    &#125; catch (RemoteException e) &#123;</div><div class="line">        // Empty</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下面来看 NotificationManagerService 中 mService 的 enqueueToast 方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">// callback 就是 TN 实例</div><div class="line">@Override</div><div class="line">public void enqueueToast(String pkg, ITransientNotification callback, int duration)</div><div class="line">&#123;</div><div class="line">    // ...</div><div class="line"></div><div class="line">    synchronized (mToastQueue) &#123;</div><div class="line">        int callingPid = Binder.getCallingPid();</div><div class="line">        long callingId = Binder.clearCallingIdentity();</div><div class="line">        try &#123;</div><div class="line">            ToastRecord record;</div><div class="line">            int index = indexOfToastLocked(pkg, callback);</div><div class="line">            // If it&apos;s already in the queue, we update it in place, we don&apos;t</div><div class="line">            // move it to the end of the queue.</div><div class="line">            if (index &gt;= 0) &#123;</div><div class="line">                record = mToastQueue.get(index);</div><div class="line">                record.update(duration);</div><div class="line">            &#125; else &#123;</div><div class="line">                // ...</div><div class="line"></div><div class="line">                Binder token = new Binder();</div><div class="line">                mWindowManagerInternal.addWindowToken(token,</div><div class="line">                        WindowManager.LayoutParams.TYPE_TOAST);</div><div class="line">                // 创建 ToastRecord 对象</div><div class="line">                record = new ToastRecord(callingPid, pkg, callback, duration, token);</div><div class="line">                // mToastQueue 添加记录</div><div class="line">                mToastQueue.add(record);</div><div class="line">                index = mToastQueue.size() - 1;</div><div class="line">                keepProcessAliveIfNeededLocked(callingPid);</div><div class="line">            &#125;</div><div class="line">            if (index == 0) &#123;</div><div class="line">                showNextToastLocked();</div><div class="line">            &#125;</div><div class="line">        &#125; finally &#123;</div><div class="line">            Binder.restoreCallingIdentity(callingId);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面代码可以看到有往 mToastQueue 中添加记录，那么什么时候执行呢，全局搜 “mToastQueue.get(“ 看到在 showNextToastLocked 方法中取出 mToastQueue 的第 0 个元素，调用 record.callback.show(record.token), record.callback 就是 TN 对象，也就是这里调了 TN 的 show 方法。下面就来看一下 TN 的 show 方法做了什么：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public void show(IBinder windowToken) &#123;</div><div class="line">    if (localLOGV) Log.v(TAG, &quot;SHOW: &quot; + this);</div><div class="line">    // 交给 mHandler 处理</div><div class="line">    mHandler.obtainMessage(0, windowToken).sendToTarget();</div><div class="line">&#125;</div><div class="line"></div><div class="line">// TN 的 mHandler</div><div class="line">final Handler mHandler = new Handler() &#123;</div><div class="line">    @Override</div><div class="line">    public void handleMessage(Message msg) &#123;</div><div class="line">    	// 所以 TN 的 show 方法处理的是这里</div><div class="line">        IBinder token = (IBinder) msg.obj;</div><div class="line">        handleShow(token);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>下面来看核心展示 Toast 的方法，也就是 TN 的 handleShow() 方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">public void handleShow(IBinder windowToken) &#123;</div><div class="line">    if (localLOGV) Log.v(TAG, &quot;HANDLE SHOW: &quot; + this + &quot; mView=&quot; + mView</div><div class="line">            + &quot; mNextView=&quot; + mNextView);</div><div class="line">    if (mView != mNextView) &#123;</div><div class="line">        handleHide();</div><div class="line">        mView = mNextView;</div><div class="line">        // ...</div><div class="line">        // 展示使用的是 WindowManager</div><div class="line">        mWM = (WindowManager)context.getSystemService(Context.WINDOW_SERVICE);</div><div class="line">        </div><div class="line">        // 下面配置的是位置参数</div><div class="line">        final Configuration config = mView.getContext().getResources().getConfiguration();</div><div class="line">        final int gravity = Gravity.getAbsoluteGravity(mGravity, config.getLayoutDirection());</div><div class="line">        mParams.gravity = gravity;</div><div class="line">        if ((gravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) == Gravity.FILL_HORIZONTAL) &#123;</div><div class="line">            mParams.horizontalWeight = 1.0f;</div><div class="line">        &#125;</div><div class="line">        if ((gravity &amp; Gravity.VERTICAL_GRAVITY_MASK) == Gravity.FILL_VERTICAL) &#123;</div><div class="line">            mParams.verticalWeight = 1.0f;</div><div class="line">        &#125;</div><div class="line">        mParams.x = mX;</div><div class="line">        mParams.y = mY;</div><div class="line">        mParams.verticalMargin = mVerticalMargin;</div><div class="line">        mParams.horizontalMargin = mHorizontalMargin;</div><div class="line">        mParams.packageName = packageName;</div><div class="line">        mParams.hideTimeoutMilliseconds = mDuration ==</div><div class="line">            Toast.LENGTH_LONG ? LONG_DURATION_TIMEOUT : SHORT_DURATION_TIMEOUT;</div><div class="line">        mParams.token = windowToken;</div><div class="line">        if (mView.getParent() != null) &#123;</div><div class="line">            if (localLOGV) Log.v(TAG, &quot;REMOVE! &quot; + mView + &quot; in &quot; + this);</div><div class="line">            mWM.removeView(mView);</div><div class="line">        &#125;</div><div class="line">        if (localLOGV) Log.v(TAG, &quot;ADD! &quot; + mView + &quot; in &quot; + this);</div><div class="line">        // 展示 Toast, 由此也可以看出，Toast 是被添加在 Window 下的</div><div class="line">        mWM.addView(mView, mParams);</div><div class="line">        trySendAccessibilityEvent();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Toast 是先调用 makeText 创建要展示的 view, 调用 show 方法时内部跨进程通知 NotificationManagerService, 再通知到 TN 执行 show 方法，最终通过 handler 添加到 Window 下。<br>再看下最开始的思考，</p>
<ol>
<li><p>makeText 会 new Toast, Toast 构造方法里创建 TN 对象，TN 有一个成员变量 mHandler, 在创建 Handler 时需要该线程有 Looper 对象，主线程的 ActivityThread 的 main() 方法有创建 Looper 对象，但子线程并没有 Looper 对象，所以会抛异常。</p>
</li>
<li><p>如果在子线程调 Looper.prepare(), 会是在主线程展示的 Toast 吗，看上面的代码很明显不是，因为 Toast, TN 都是在子线程创建的，所以 mHandler 也是在子线程创建的，处理消息时的 Looper 也是子线程创建的，所以展示也是在子线程的。</p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hexiaosa.com/2018/08/12/ThreadPool/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hexiaosa">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexiaosa">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/12/ThreadPool/" itemprop="url">并发编程 —— 线程池简介和源码分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-12T14:39:43+08:00">
                2018-08-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="线程池简介"><a href="#线程池简介" class="headerlink" title="线程池简介"></a>线程池简介</h3><p>线程池的优点：提高性能，提高线程的利用率，可控制线程的最大并发数，方便线程管理。<br>线程池的核心类是 ThreadPoolExecutor, 可通过 Executors 中的几个方法创建线程池，分别是：</p>
<ol>
<li><p>CachedThreadPool<br>核心线程数为 0, 线程数量无上限</p>
</li>
<li><p>FixedThreadPool<br>核心线程数由使用者自己指定，无非核心线程，线程空闲时不会被回收，除非线程池被关闭</p>
</li>
<li><p>ScheduledThreadPool<br>指定数量的核心线程数，线程数无上限，非核心线程空闲时会被回收</p>
</li>
<li><p>SingleThreadExecutor<br>核心线程为 1, 无非核心线程，线程空闲时不会被回收。意义在于使得任务都放在同一线程处理，不必考虑线程同步问题。</p>
</li>
</ol>
<h5 id="线程池构造方法参数介绍"><a href="#线程池构造方法参数介绍" class="headerlink" title="线程池构造方法参数介绍"></a>线程池构造方法参数介绍</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public ThreadPoolExecutor(int corePoolSize,</div><div class="line">                          int maximumPoolSize,</div><div class="line">                          long keepAliveTime,</div><div class="line">                          TimeUnit unit,</div><div class="line">                          BlockingQueue&lt;Runnable&gt; workQueue,</div><div class="line">                          ThreadFactory threadFactory,</div><div class="line">                          RejectedExecutionHandler handler) &#123;</div><div class="line">    // ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面是线程池的构造方法，分析一下创建线程池的七个参数的含义：</p>
<ol>
<li><p>corePoolSize<br>核心线程数，在空闲时不会被回收，在线程池关闭后才会被回收（allowCoreThreadTimeOut 被设为 true 时会闲置 keepAliveTime 后回收）。</p>
</li>
<li><p>maximunPoolSize<br>线程数上限，可利用该参数控制线程最大并发数，当运行的线程超过这个数量时会被阻塞。</p>
</li>
<li><p>keepAliveTime<br>非核心线程的闲置时长，超过这个时长就会被回收，当 allowCoreThreadTimeOut 被设为 true 后，这个时长也同样作用于核心线程。</p>
</li>
<li><p>unit<br>keepAliveTime 的时间单位。</p>
</li>
<li><p>workQueue<br>线程池中的任务队列。</p>
</li>
<li><p>threadFactory<br>用于创建线程，它只有一个 newThread(Runnable r) 方法。</p>
</li>
<li><p>handler<br>如果执行（添加）任务失败，则会执行 handler.rejectedExecution(command, this); 这个方法在需要处理拒绝后的操作时由我们自己实现来处理。</p>
</li>
</ol>
<h5 id="线程池执行过程"><a href="#线程池执行过程" class="headerlink" title="线程池执行过程"></a>线程池执行过程</h5><p>线程池创建过后执行会调用 ThreadPoolExecutor 的 execute(Runnable) 方法来执行线程，步骤如下：</p>
<ol>
<li><p>如果当前线程数小于核心线程，则创建新的线程保存到核心线程并执行；</p>
</li>
<li><p>否则，核心线程数已满，则插入到任务队列中等待</p>
</li>
<li><p>插入到任务队列失败，则启动非核心线程来执行</p>
</li>
<li><p>启动非核心线程失败，则 reject.</p>
</li>
</ol>
<h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><p>那么线程池传过去的 Runnable 是怎么运行的，任务队列是怎么排队的，核心线程又是怎么创建和销毁的，从源码中找答案。</p>
<h5 id="Runnabla-是怎么运行的"><a href="#Runnabla-是怎么运行的" class="headerlink" title="Runnabla 是怎么运行的"></a>Runnabla 是怎么运行的</h5><p>首先调用 execute 方法，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public void execute(Runnable command) &#123;</div><div class="line">    </div><div class="line">    int c = ctl.get();</div><div class="line">    // 首先判断工作线程数量小于核心线程，直接在核心线程执行</div><div class="line">    if (workerCountOf(c) &lt; corePoolSize) &#123;</div><div class="line">        if (addWorker(command, true))</div><div class="line">            return;</div><div class="line">        c = ctl.get();</div><div class="line">    &#125;</div><div class="line">    // 添加到任务队列中等待</div><div class="line">    if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</div><div class="line">        int recheck = ctl.get();</div><div class="line">        if (! isRunning(recheck) &amp;&amp; remove(command))</div><div class="line">            reject(command);</div><div class="line">        else if (workerCountOf(recheck) == 0)</div><div class="line">            addWorker(null, false);</div><div class="line">    &#125;</div><div class="line">    // 添加到非核心线程，失败则 reject</div><div class="line">    else if (!addWorker(command, false))</div><div class="line">        reject(command);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接下来看 addWorker 方法，执行 Runnable 的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">private boolean addWorker(Runnable firstTask, boolean core) &#123;</div><div class="line">    // ... 一些校验条件</div><div class="line"></div><div class="line">    boolean workerStarted = false;</div><div class="line">    boolean workerAdded = false;</div><div class="line">    Worker w = null;</div><div class="line">    try &#123;</div><div class="line">    	// 创建 Worker, 内部赋值了 firstTask 并创建了线程，通过 threadFactory.new Thread(worker)</div><div class="line">        w = new Worker(firstTask);</div><div class="line">        final Thread t = w.thread;</div><div class="line">        if (t != null) &#123;</div><div class="line">            final ReentrantLock mainLock = this.mainLock;</div><div class="line">            mainLock.lock();</div><div class="line">            try &#123;</div><div class="line">                int rs = runStateOf(ctl.get());</div><div class="line">                // 对运行状态做校验</div><div class="line">                if (rs &lt; SHUTDOWN ||</div><div class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123;</div><div class="line">                    // ...</div><div class="line">                    // 把创建的 worker 对象保存下来</div><div class="line">                    workers.add(w);</div><div class="line">                    int s = workers.size();</div><div class="line">                    if (s &gt; largestPoolSize)</div><div class="line">                        largestPoolSize = s;</div><div class="line">                    workerAdded = true;</div><div class="line">                &#125;</div><div class="line">            &#125; finally &#123;</div><div class="line">                mainLock.unlock();</div><div class="line">            &#125;</div><div class="line">            // 成功添加，则开始执行，t.start 会调用 worker.run 方法，因为 newThread 时传的 Runnable 对象是 worker</div><div class="line">            if (workerAdded) &#123;</div><div class="line">                t.start();</div><div class="line">                workerStarted = true;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; finally &#123;</div><div class="line">        if (! workerStarted)</div><div class="line">            addWorkerFailed(w);</div><div class="line">    &#125;</div><div class="line">    return workerStarted;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面分析到 t.start 调的是 worker.run, worker.run 实际执行的是 runWorker(), 下面接着来看这个方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">final void runWorker(Worker w) &#123;</div><div class="line">    Thread wt = Thread.currentThread();</div><div class="line">    Runnable task = w.firstTask; // 这里的 task 就是 execute 方法传的 Runnable 对象</div><div class="line">    w.firstTask = null;</div><div class="line">    w.unlock(); // allow interrupts</div><div class="line">    boolean completedAbruptly = true;</div><div class="line">    try &#123;</div><div class="line">        // 循环取 task 执行，第一次 task 不是 null, 第一次循环执行完，下一次就会取 getTask</div><div class="line">        while (task != null || (task = getTask()) != null) &#123;</div><div class="line">            w.lock();</div><div class="line">            // ... 校验</div><div class="line">            try &#123;</div><div class="line">                beforeExecute(wt, task);</div><div class="line">                Throwable thrown = null;</div><div class="line">                try &#123;</div><div class="line">                    // 这里就是我们调用 execute 方法时实际执行的地方了</div><div class="line">                    task.run();</div><div class="line">                &#125; catch (RuntimeException x) &#123;</div><div class="line">                    thrown = x; throw x;</div><div class="line">                &#125; catch (Error x) &#123;</div><div class="line">                    thrown = x; throw x;</div><div class="line">                &#125; catch (Throwable x) &#123;</div><div class="line">                    thrown = x; throw new Error(x);</div><div class="line">                &#125; finally &#123;</div><div class="line">                    afterExecute(task, thrown);</div><div class="line">                &#125;</div><div class="line">            &#125; finally &#123;</div><div class="line">                task = null;</div><div class="line">                w.completedTasks++;</div><div class="line">                w.unlock();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        completedAbruptly = false;</div><div class="line">    &#125; finally &#123;</div><div class="line">        processWorkerExit(w, completedAbruptly);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面就看到 Runnable 实际执行的部分了，Runnable 怎么执行的分析就到此结束。</p>
<h5 id="任务队列是怎么排队的呢"><a href="#任务队列是怎么排队的呢" class="headerlink" title="任务队列是怎么排队的呢"></a>任务队列是怎么排队的呢</h5><p>上面代码中看到一个 for 循环不断 getTask 就是获取 Runnable 的过程，下面看 getTask 方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">private Runnable getTask() &#123;</div><div class="line">    boolean timedOut = false; // Did the last poll() time out?</div><div class="line"></div><div class="line">    for (;;) &#123;</div><div class="line">        int c = ctl.get();</div><div class="line">        int rs = runStateOf(c);</div><div class="line"></div><div class="line">        // Check if queue empty only if necessary.</div><div class="line">        if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</div><div class="line">            decrementWorkerCount();</div><div class="line">            return null;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        int wc = workerCountOf(c);</div><div class="line"></div><div class="line">        // Are workers subject to culling?</div><div class="line">        boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</div><div class="line"></div><div class="line">        if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</div><div class="line">            &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) &#123;</div><div class="line">            if (compareAndDecrementWorkerCount(c))</div><div class="line">                return null;</div><div class="line">            continue;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        try &#123;</div><div class="line">        	// 取任务就是在这里，从 workQueue 中取任务，是通过 workQueue.offer(runnable) 添加的</div><div class="line">            Runnable r = timed ?</div><div class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</div><div class="line">                workQueue.take();</div><div class="line">            if (r != null)</div><div class="line">                return r;</div><div class="line">            timedOut = true;</div><div class="line">        &#125; catch (InterruptedException retry) &#123;</div><div class="line">            timedOut = false;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="核心线程池又是怎么创建和销毁的"><a href="#核心线程池又是怎么创建和销毁的" class="headerlink" title="核心线程池又是怎么创建和销毁的"></a>核心线程池又是怎么创建和销毁的</h5><p>创建核心线程就是在 new Worker 时创建的线程, runWorker方法中 while 循环 getTask 获取 Runnable, getTask 获取不到 Runnable 时会调用 processWorkerExit 来销毁线程，getTask 获取 Runnalble 是通过 workQueue.poll() / workQueue.take().</p>
<p>当创建线程池时设置空闲一定时间就销毁时，就调用 workQueue.poll(), 下面看一下 poll 方法的源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">public E poll(long timeout, TimeUnit unit) throws InterruptedException &#123;</div><div class="line">    E x = null;</div><div class="line">    int c = -1;</div><div class="line">    // timeout 就是线程闲置这个时间后就需要销毁的</div><div class="line">    long nanos = unit.toNanos(timeout);</div><div class="line">    final AtomicInteger count = this.count;</div><div class="line">    final ReentrantLock takeLock = this.takeLock;</div><div class="line">    takeLock.lockInterruptibly();</div><div class="line">    try &#123;</div><div class="line">        while (count.get() == 0) &#123;</div><div class="line">            if (nanos &lt;= 0)</div><div class="line">                return null;</div><div class="line">            // 如果队列为空，线程就等待 timeout 时间</div><div class="line">            nanos = notEmpty.awaitNanos(nanos);</div><div class="line">        &#125;</div><div class="line">        x = dequeue();</div><div class="line">        c = count.getAndDecrement();</div><div class="line">        if (c &gt; 1)</div><div class="line">            notEmpty.signal();</div><div class="line">    &#125; finally &#123;</div><div class="line">        takeLock.unlock();</div><div class="line">    &#125;</div><div class="line">    if (c == capacity)</div><div class="line">        signalNotFull();</div><div class="line">    // 所以如果这里在等待 timeout 时间后还没有任务，返回到的就是空</div><div class="line">    return x;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面 poll 方法中返回为空时，上面 runWorker 方法中的 while 循环就结束了，那么久会执行 processWorkerExit 方法来中断这个线程，于是就结束执行了这个线程。</p>
<p>设置 allowCoreThreadTimeOut 为 false 时就调用 workQueue.take(), workQueue.take() 方法看一下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public E take() throws InterruptedException &#123;</div><div class="line">    E x;</div><div class="line">    int c = -1;</div><div class="line">    final AtomicInteger count = this.count;</div><div class="line">    final ReentrantLock takeLock = this.takeLock;</div><div class="line">    takeLock.lockInterruptibly();</div><div class="line">    try &#123;</div><div class="line">        // 当队列为空时，线程会一直处于等待状态</div><div class="line">        while (count.get() == 0) &#123;</div><div class="line">            notEmpty.await();</div><div class="line">        &#125;</div><div class="line">        x = dequeue();</div><div class="line">        c = count.getAndDecrement();</div><div class="line">        if (c &gt; 1)</div><div class="line">            notEmpty.signal();</div><div class="line">    &#125; finally &#123;</div><div class="line">        takeLock.unlock();</div><div class="line">    &#125;</div><div class="line">    return x;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>所以如果核心线程是不可销毁的，那么会调用 workQueue.take(), 在没有任务时线程就会处于等待状态，直到有任务再返回，所以这样情况下核心线程是不会被销毁的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hexiaosa.com/2018/08/11/Activity-setContentView/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hexiaosa">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexiaosa">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/11/Activity-setContentView/" itemprop="url">从源码分析 setContentView 做了什么</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-11T23:44:51+08:00">
                2018-08-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>从源码分析 Activity 的 onCreate 方法的 setContentView 都做了什么。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public void setContentView(int layoutResID) &#123;</div><div class="line">    getWindow().setContentView(layoutResID);</div><div class="line">    // 如果需要的话，初始化 ActionBar</div><div class="line">    initWindowDecorActionBar();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中 getWindow() 返回的是 PhoneWindow, 它的初始化是在 Activity.attach 时赋值的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mWindow = PolicyManager.makeNewWindow(this); // 实际执行的在 Policy.makeNewWindows</div></pre></td></tr></table></figure></p>
<p>下面看 PhoneWindow.setContentView, 这里做的就是初始化 DecoreView 和加载给定的 layout id.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public void setContentView(int layoutResID) &#123;</div><div class="line">    if (mContentParent == null) &#123;</div><div class="line">    	// 初始化 DecoreView, 这里会赋值 mContentParent</div><div class="line">        installDecor();</div><div class="line">    &#125; else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</div><div class="line">        mContentParent.removeAllViews();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 是否有 transition</div><div class="line">    if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</div><div class="line">        final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,</div><div class="line">                getContext());</div><div class="line">        transitionTo(newScene);</div><div class="line">    &#125; else &#123;</div><div class="line">    	// 直接加载 layoutResID，到这里 layout 已加载完毕</div><div class="line">        mLayoutInflater.inflate(layoutResID, mContentParent);</div><div class="line">    &#125;</div><div class="line">    final Callback cb = getCallback();</div><div class="line">    if (cb != null &amp;&amp; !isDestroyed()) &#123;</div><div class="line">        cb.onContentChanged();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接下来我们就来看 installDecor 方法做了什么吧，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">private void installDecor() &#123;</div><div class="line">	// 初始化 mDecor</div><div class="line">    if (mDecor == null) &#123;</div><div class="line">        mDecor = generateDecor();</div><div class="line">        // ...</div><div class="line">    &#125;</div><div class="line">    // 初始化 mContentParent</div><div class="line">    if (mContentParent == null) &#123;</div><div class="line">        mContentParent = generateLayout(mDecor);</div><div class="line"></div><div class="line">        // Set up decor part of UI to ignore fitsSystemWindows if appropriate.</div><div class="line">        mDecor.makeOptionalFitsSystemWindows();</div><div class="line"></div><div class="line">        // 填充 title 和 content</div><div class="line">        final DecorContentParent decorContentParent = (DecorContentParent) mDecor.findViewById(</div><div class="line">                R.id.decor_content_parent);</div><div class="line"></div><div class="line">        // ...</div><div class="line"></div><div class="line">        if (mDecor.getBackground() == null &amp;&amp; mBackgroundFallbackResource != 0) &#123;</div><div class="line">            mDecor.setBackgroundFallback(mBackgroundFallbackResource);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (hasFeature(FEATURE_ACTIVITY_TRANSITIONS)) &#123;</div><div class="line">            // 设置一些 transition</div><div class="line">            // ...</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>初始化 DecoreView 方法中就是 new 了一个 DecoreView, 下面看初始化 mContentParent 的方法，这一段代码比较多，就主要介绍一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">protected ViewGroup generateLayout(DecorView decor) &#123;</div><div class="line">	// 先设置 style</div><div class="line">	// ... </div><div class="line"></div><div class="line">	// 根据版本和设置来决定是否需要菜单</div><div class="line">	// ... </div><div class="line"></div><div class="line">    mDecor.startChanging();</div><div class="line"></div><div class="line">	// 添加指定需要的 View(title, actionBar, 等)</div><div class="line">	View in = mLayoutInflater.inflate(layoutResource, null);</div><div class="line">    decor.addView(in, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));</div><div class="line">    mContentRoot = (ViewGroup) in;</div><div class="line"></div><div class="line">	// 获取 contentParent</div><div class="line">	ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);</div><div class="line"></div><div class="line">	// 设置背景，title, 颜色 等</div><div class="line"></div><div class="line">    mDecor.finishChanging();</div><div class="line">	return contentParent;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样也就可以理解下图了：<br><img src="/image/activity_view.png" alt="activity_view"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hexiaosa.com/2018/08/09/LruCache-theory/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hexiaosa">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexiaosa">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/09/LruCache-theory/" itemprop="url">LruCache 原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-09T11:04:00+08:00">
                2018-08-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="LruCache-的使用"><a href="#LruCache-的使用" class="headerlink" title="LruCache 的使用"></a>LruCache 的使用</h3><p>LruCache 是用于缓存的，缓存的原理是使用近期最少使用的方法，使用例子代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">int cacheSize = ((int) (Runtime.getRuntime().maxMemory() / 1024)) / 8; // 最大可缓存的大小</div><div class="line">LruCache&lt;String, Bitmap&gt; lruCache = new LruCache&lt;String, Bitmap&gt;(cacheSize) &#123;</div><div class="line">    @Override</div><div class="line">    protected int sizeOf(String key, Bitmap value) &#123;</div><div class="line">        // 计算每次存放的 value 的大小</div><div class="line">        return value.getRowBytes() * value.getHeight() * 1024;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected Bitmap create(String key) &#123;</div><div class="line">        // 自己根据 key 来创建需要的 value, 在 get 方法取不到 key 对应的 value 时会调用该方法</div><div class="line">        // 也可以选择不实现该方法，在取到的 value 是 null 时自己根据需要创建</div><div class="line">        return super.create(key);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">// 此处仅作为演示，实际使用时可根据需要优化 bitmap 的加载</div><div class="line">lruCache.put(&quot;test1&quot;, BitmapFactory.decodeResource(getApplicationContext().getResources(), R.mipmap.ic_launcher));</div><div class="line">if (lruCache.get(&quot;test1&quot;) == null) &#123;</div><div class="line">	lruCache.put(&quot;test1&quot;, bitmap);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h3><p>上面的使用方法中主要的就是 put, get 两个方法，下面具体看这两个方法都做了什么。</p>
<p>put 方法分析：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public final V put(K key, V value) &#123;</div><div class="line">    // key, value 不可为 null</div><div class="line">    if (key == null || value == null) &#123;</div><div class="line">        throw new NullPointerException(&quot;key == null || value == null&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    V previous; // key 原有的 value</div><div class="line">    synchronized (this) &#123;</div><div class="line">    	// 存的次数增加</div><div class="line">        putCount++;</div><div class="line">        // 存的 size 增加</div><div class="line">        size += safeSizeOf(key, value);</div><div class="line">        // 实际存 value, 原来的 value 返回</div><div class="line">        previous = map.put(key, value);</div><div class="line">        if (previous != null) &#123;</div><div class="line">        	// 原来的 value 不为 null 则 size 也相应的减少</div><div class="line">            size -= safeSizeOf(key, previous);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (previous != null) &#123;</div><div class="line">    	// 删除了原来的 value, 根据自己需要做相应的操作</div><div class="line">        entryRemoved(false, key, previous, value);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 在缓存的大小已经超过 maxSize 时去除近期最少使用的 value</div><div class="line">    trimToSize(maxSize);</div><div class="line">    return previous;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>get 方法分析：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public final V get(K key) &#123;</div><div class="line">	// key 不可为 null</div><div class="line">    if (key == null) &#123;</div><div class="line">        throw new NullPointerException(&quot;key == null&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 记录查到的 value</div><div class="line">    V mapValue;</div><div class="line">    synchronized (this) &#123;</div><div class="line">        mapValue = map.get(key);</div><div class="line">        if (mapValue != null) &#123;</div><div class="line">        	// 查到缓存的次数加 1</div><div class="line">            hitCount++;</div><div class="line">            return mapValue;</div><div class="line">        &#125;</div><div class="line">        // 没有查到缓存的次数加 1</div><div class="line">        missCount++;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    V createdValue = create(key);</div><div class="line"></div><div class="line">    // 看自己是否实现了 create 方法，如果没有实现就 return null</div><div class="line">    if (createdValue == null) &#123;</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // create 方法创建过程中可能已经 put 了同样的 key, 如果相同则释放掉 create 方法创建的，保留  put 进去的</div><div class="line">    synchronized (this) &#123;</div><div class="line">    	// create 次数加 1</div><div class="line">        createCount++;</div><div class="line">        // 存 create 的，返回 key 对应的原来的值，也就是在 create 过程中 put 进去了相同 key 的值(mapValue)</div><div class="line">        mapValue = map.put(key, createdValue);</div><div class="line"></div><div class="line">        // mapValue 有值，则以 put 的为主，否则就正常保存 create 的，size 相应增加</div><div class="line">        if (mapValue != null) &#123;</div><div class="line">            map.put(key, mapValue);</div><div class="line">        &#125; else &#123;</div><div class="line">            size += safeSizeOf(key, createdValue);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // mapValue 有值，则执行清除 createValue 时根据我们的需要要做的操作，返回 mapValue</div><div class="line">    // 否则就是 create 执行正常，在缓存的大小已经超过 maxSize 时去除近期最少使用的 value, 返回 createValue</div><div class="line">    if (mapValue != null) &#123;</div><div class="line">        entryRemoved(false, key, createdValue, mapValue);</div><div class="line">        return mapValue;</div><div class="line">    &#125; else &#123;</div><div class="line">        trimToSize(maxSize);</div><div class="line">        return createdValue;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>那么最近最少使用原理是怎么实现的呢？就是靠 LinkedHashMap, 在 new LruCache 时创建 map,<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">this.map = new LinkedHashMap&lt;K, V&gt;(0, 0.75f, true);</div></pre></td></tr></table></figure></p>
<p>这里把 accesssOrder 参数的值赋为 true, accesssOrder 在官方文档的解释是：the ordering mode - true for access-order, false for insertion-order, 也是是设为 true 则表示以访问排序。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hexiaosa.com/2018/08/07/custom-view-event1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hexiaosa">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexiaosa">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/07/custom-view-event1/" itemprop="url">自定义 View —— 事件体系例子 StickyLayout</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-07T18:58:51+08:00">
                2018-08-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文例子是《Android 开发艺术探索》作者的 github, <a href="https://github.com/singwhatiwanna/PinnedHeaderExpandableListView。结合该例子学习自定义" target="_blank" rel="external">https://github.com/singwhatiwanna/PinnedHeaderExpandableListView。结合该例子学习自定义</a> View 的事件体系和弹性滑动。<br>效果图也看 github 上的吧，都一样的。</p>
<blockquote>
<p>思路：<br>先是随着滑动更改头部的高度，这一部分是由 StickyLayout 处理 onTouchEvent 事件；<br>头部高度为 0 时，StickyLayout 不再处理，分发给子 View 处理；<br>滑动过程中松手后，根据滑动的位置决定是否实现惯性滑动，以及滑动方向。</p>
</blockquote>
<p>上述是否自己处理 onTouchEvent 事件是由 onInterceptTouchEvent() 实现的，return true 则会调自己的 onTouchEvent，否则会到子 View 的 onInterceptTouchEvent/onTouchEvent（根据子 View 是 ViewGroup 还是 View 决定，View 是直接执行 onTouchEvent 的，因为 View 没有 onInterceptTouchEvent, 最后一层是肯定会执行 onTouchEvent 的）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public boolean onInterceptTouchEvent(MotionEvent event) &#123;</div><div class="line">    int intercepted = 0;</div><div class="line">    switch (event.getAction()) &#123;</div><div class="line">    case MotionEvent.ACTION_DOWN: &#123;</div><div class="line">        // ...</div><div class="line">        intercepted = 0;</div><div class="line">        break;</div><div class="line">    &#125;</div><div class="line">    case MotionEvent.ACTION_MOVE: &#123;</div><div class="line">        int deltaX = x - mLastXIntercept;</div><div class="line">        int deltaY = y - mLastYIntercept;</div><div class="line">        if (y &lt;= getHeaderHeight()) &#123;</div><div class="line">        	// 自己不拦截，看子级的实现</div><div class="line">            intercepted = 0;</div><div class="line">        &#125; else if (Math.abs(deltaY) &lt;= Math.abs(deltaX)) &#123;</div><div class="line">        	// 这样认为是横向滑动，不处理 onTouchEvent</div><div class="line">            intercepted = 0;</div><div class="line">            // 否则当滑动距离 &gt; mTouchSlop(滑动的最小距离) 时就处理 onTouchEvent</div><div class="line">        &#125; else if (mStatus == STATUS_EXPANDED &amp;&amp; deltaY &lt;= -mTouchSlop) &#123;</div><div class="line">            intercepted = 1;</div><div class="line">        &#125; else if (deltaY &gt;= mTouchSlop) &#123;</div><div class="line">            intercepted = 1;</div><div class="line">        &#125;</div><div class="line">        break;</div><div class="line">    &#125;</div><div class="line">    case MotionEvent.ACTION_UP: &#123;</div><div class="line">        // ...</div><div class="line">        break;</div><div class="line">    &#125;</div><div class="line">    return intercepted != 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Override</div><div class="line">public boolean onTouchEvent(MotionEvent event) &#123;</div><div class="line">    int x = (int) event.getX();</div><div class="line">    int y = (int) event.getY();</div><div class="line">    switch (event.getAction()) &#123;</div><div class="line">    case MotionEvent.ACTION_DOWN: &#123;</div><div class="line">        break;</div><div class="line">    &#125;</div><div class="line">    case MotionEvent.ACTION_MOVE: &#123;</div><div class="line">        int deltaX = x - mLastX;</div><div class="line">        int deltaY = y - mLastY;</div><div class="line">        // 通过 LayoutParams 实现动画</div><div class="line">        setHeaderHeight(mHeaderHeight);</div><div class="line">        break;</div><div class="line">    &#125;</div><div class="line">    case MotionEvent.ACTION_UP: &#123;</div><div class="line">        // 这里做了下判断，当松开手的时候，会自动向两边滑动，具体向哪边滑，要看当前所处的位置</div><div class="line">        int destHeight = 0;</div><div class="line">        if (mHeaderHeight &lt;= mOriginalHeaderHeight * 0.5) &#123;</div><div class="line">            destHeight = 0;</div><div class="line">            mStatus = STATUS_COLLAPSED;</div><div class="line">        &#125; else &#123;</div><div class="line">            destHeight = mOriginalHeaderHeight;</div><div class="line">            mStatus = STATUS_EXPANDED;</div><div class="line">        &#125;</div><div class="line">        // 慢慢滑向终点</div><div class="line">        this.smoothSetHeaderHeight(mHeaderHeight, destHeight, 500);</div><div class="line">        break;</div><div class="line">    &#125;</div><div class="line">    default:</div><div class="line">        break;</div><div class="line">    &#125;</div><div class="line">    mLastX = x;</div><div class="line">    mLastY = y;</div><div class="line">    return true;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hexiaosa.com/2018/07/31/GreenDao-Cache/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hexiaosa">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexiaosa">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/31/GreenDao-Cache/" itemprop="url">GreenDao 缓存</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-07-31T11:34:33+08:00">
                2018-07-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>在项目中遇到这样的问题，数据库使用的 GreenDao, 两个 Activity, 分别添加同一个 Fragment, 查本地数据库，实体类中有一个是否选中状态的字段是不保存到数据库的，@transient 标记的，发现会出现这样的现象：在 Activity1 中的 Fragment 查出来，第一个位置选中，到 Activity2 中的 Fragment 查出来的第一个位置也是选中的，what???</p>
</blockquote>
<p> 两个 Activity 分别 new Fragment, 这是在两个 Fragment 对象中的，最后 debug 跟踪到原来是在 Activity2 中数据库查出来的数据就是选中的，脑子里闪现出难道是 GreenDao 有缓存，于是搜索 “GreenDao 缓存”，果然是有，网上给出的清除缓存的方式就是调 daoSession.clear(), 这样的话不是把所有的表缓存都给清了吗，怎么让只是这个查询不缓存呢，看下 daoSession.clear() 里面做了什么</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public void clear() &#123;</div><div class="line">    ***DaoConfig.getIdentityScope().clear();</div><div class="line">    ***DaoConfig.getIdentityScope().clear();</div><div class="line">    ***DaoConfig.getIdentityScope().clear();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到清除的就是 DaoConfig 的 identityScope，下面看下这个做了什么<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public final class DaoConfig implements Cloneable &#123;</div><div class="line"></div><div class="line">    //...</div><div class="line">    private IdentityScope&lt;?, ?&gt; identityScope;</div><div class="line"></div><div class="line">    //...</div><div class="line"></div><div class="line">    // identityScope 在这里被赋值</div><div class="line">    @SuppressWarnings(&quot;rawtypes&quot;)</div><div class="line">    public void initIdentityScope(IdentityScopeType type) &#123;</div><div class="line">        if (type == IdentityScopeType.None) &#123;</div><div class="line">        	// 当 type 是 IdentityScopeType.None 时就没有缓存了</div><div class="line">            identityScope = null;</div><div class="line">        &#125; else if (type == IdentityScopeType.Session) &#123;</div><div class="line">            if (keyIsNumeric) &#123;</div><div class="line">                identityScope = new IdentityScopeLong();</div><div class="line">            &#125; else &#123;</div><div class="line">                identityScope = new IdentityScopeObject();</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            throw new IllegalArgumentException(&quot;Unsupported type: &quot; + type);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>设置 identityScope 是在 new Session 时传的，自动生成的 DaoMaster 类有两个 newSession 方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"> public class DaoMaster extends AbstractDaoMaster &#123;</div><div class="line">    //...</div><div class="line">    public DaoSession newSession() &#123;</div><div class="line">        return new DaoSession(db, IdentityScopeType.Session, daoConfigMap);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public DaoSession newSession(IdentityScopeType type) &#123;</div><div class="line">        return new DaoSession(db, type, daoConfigMap);</div><div class="line">    &#125;</div><div class="line">    //...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以只要在 newSession 时传 IdentityScopeType.None 就可以不使用缓存了。</p>
<p>当然，这次遇到的问题是查出来的状态需要是不选中的，也可以再查出来之后是选中状态的话进行修改，具体就要看具体问题适合哪种解决方式了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Hexiaosa</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">37</span>
                  <span class="site-state-item-name">Artikel</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hexiaosa</span>

  
</div>


  <div class="powered-by">Erstellt mit  <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
