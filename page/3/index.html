<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Hexiaosa">
<meta property="og:url" content="http://hexiaosa.com/page/3/index.html">
<meta property="og:site_name" content="Hexiaosa">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexiaosa">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://hexiaosa.com/page/3/"/>





  <title>Hexiaosa</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexiaosa</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Startseite
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archiv
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hexiaosa.com/2018/05/24/Handler/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hexiaosa">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexiaosa">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/24/Handler/" itemprop="url">Handler 机制详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-24T16:13:41+08:00">
                2018-05-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Handler-的原理看这张图就可以知道"><a href="#Handler-的原理看这张图就可以知道" class="headerlink" title="Handler 的原理看这张图就可以知道"></a>Handler 的原理看这张图就可以知道</h3><p><img src="/image/handler.png" alt="handler"></p>
<p>Handler sendMessage(msg) 会调用 sendMessageAtTime(msg, uptimeMillis), 在这里会调 enqueueMessage(queue, msg, uptimeMillis), 其中 queue 是 handler 的全局变量 mQueue, 在构造函数里，有这两行代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mLooper = Looper.myLooper();</div><div class="line">mQueue = mLooper.mQueue;</div></pre></td></tr></table></figure></p>
<p>最终会调用 queue.enqueueMessage(msg, uptimeMiilis), 在这个方法里会设置 msg.target = this, 然后把该 msg 插入 queue 中。<br>Looper.loop() 方法会循环取 mQueue 中的值，取到消息就分发执行。</p>
<h3 id="思考："><a href="#思考：" class="headerlink" title="思考："></a>思考：</h3><h6 id="1-为什么子线程中直接-new-Handler-会报异常呢？"><a href="#1-为什么子线程中直接-new-Handler-会报异常呢？" class="headerlink" title="1. 为什么子线程中直接 new Handler() 会报异常呢？"></a>1. 为什么子线程中直接 new Handler() 会报异常呢？</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">mLooper = Looper.myLooper();</div><div class="line">if (mLooper == null) &#123;</div><div class="line">    throw new RuntimeException(</div><div class="line">        &quot;Can&apos;t create handler inside thread that has not called Looper.prepare()&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面一段代码是 Handler 的构造方法中的一段代码，创建 Handler 时会取 Looper.myLooper(), 返回的是当前线程的 Looper 对象，由于子线程中还没有 Looper 对象，所以会报异常。主线程是在 ActivityThread 的 main 方法中创建的 Looper 对象。<br>注：子线程先调用 Looper.prepare() 之后也可以创建 Handler, 但是更新 UI 时不建议这样做，因为这样还是在子线程中更新的 UI, 还是线程不安全的。</p>
<h6 id="2-一个线程只能有一个-Looper-对象？"><a href="#2-一个线程只能有一个-Looper-对象？" class="headerlink" title="2. 一个线程只能有一个 Looper 对象？"></a>2. 一个线程只能有一个 Looper 对象？</h6><p>创建 Looper 对象是调用 Looper.prepare, 其源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if (sThreadLocal.get() != null) &#123;</div><div class="line">    throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);</div><div class="line">&#125;</div><div class="line">sThreadLocal.set(new Looper(quitAllowed));</div></pre></td></tr></table></figure></p>
<p>这里使用 ThreadLocal 保证了一个线程只有一个 Looper 对象。</p>
<h6 id="3-主线程的-Looper-loop-无限循环为什么不会造成-ANR"><a href="#3-主线程的-Looper-loop-无限循环为什么不会造成-ANR" class="headerlink" title="3. 主线程的 Looper.loop 无限循环为什么不会造成 ANR?"></a>3. 主线程的 Looper.loop 无限循环为什么不会造成 ANR?</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">for (;;) &#123;</div><div class="line">    Message msg = queue.next(); // might block</div><div class="line">    if (msg == null) &#123;</div><div class="line">        // No message indicates that the message queue is quitting.</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>之所以不会造成 ANR 就是因为消息的阻塞和唤醒机制，重点在 queue.next() 获取新的消息时，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Message next() &#123;</div><div class="line">    // ...</div><div class="line">    for (;;) &#123;</div><div class="line">        //...</div><div class="line"></div><div class="line">        nativePollOnce(ptr, nextPollTimeoutMillis); // 重点在这里，</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>nativePollOnce 会引起阻塞消息队列，在唤醒时间到的时候再唤醒。<br>在此处会唤醒，还有在 enqueueMessage 时，如果有在消息队列头部插入的话，就会调用唤醒 nativeWake(mPtr).<br>推荐这篇文章<a href="https://my.oschina.net/youranhongcha/blog/492591，讲的很清楚。" target="_blank" rel="external">https://my.oschina.net/youranhongcha/blog/492591，讲的很清楚。</a></p>
<h6 id="4-Handler发送延迟消息的原理"><a href="#4-Handler发送延迟消息的原理" class="headerlink" title="4. Handler发送延迟消息的原理"></a>4. Handler发送延迟消息的原理</h6><p>发送延迟消息，最终一样都是调用 sendMessageAtTime，给设置一个唤醒的时间，在时间到了就唤醒。</p>
<h6 id="5-是否可以停止消息循环"><a href="#5-是否可以停止消息循环" class="headerlink" title="5. 是否可以停止消息循环"></a>5. 是否可以停止消息循环</h6><p>Looper 提供了一个 quit() 方法，那么主线程的 Looper 能否停止循环呢，试图调 Looper.getMainLooper().quit() 会抛出异常 “Main thread not allowed to quit.”，原因：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// MessageQueue</div><div class="line">void quit(boolean safe) &#123;</div><div class="line">    /* mQuitAllowed 是在创建 MessageQueue 时指定的，主线程创建 Looper 是调用 Looper.prepareMainLoop(), 传进来的是 false, 所以停止主线程的 Looper 会抛异常 */</div><div class="line">    if (!mQuitAllowed) &#123; </div><div class="line">        throw new IllegalStateException(&quot;Main thread not allowed to quit.&quot;);</div><div class="line">    &#125;</div><div class="line">    // ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>子线程的 Looper 创建是调 Looper.prepare, 传的 mQuitAllowed 是 true, 所以子线程是可以停止的</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hexiaosa.com/2018/01/30/ActivitySection/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hexiaosa">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexiaosa">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/30/ActivitySection/" itemprop="url">Activity 相关知识</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-01-30T09:17:37+08:00">
                2018-01-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="关于生命周期"><a href="#关于生命周期" class="headerlink" title="关于生命周期"></a>关于生命周期</h3><p>两个 Activity 跳转，不管有没有执行 onNewIntent, 都会前一个 Activity 执行 onPause, onStop, 后一个 Activity 执行 onStart, onResume 方法。</p>
<h3 id="关于-configChanges"><a href="#关于-configChanges" class="headerlink" title="关于 configChanges"></a>关于 configChanges</h3><p>在 AndroidManifest 文件中声明 configChanges, 那么当声明的系统配置发生变化时，Activity 不会重新执行生命周期，只会调用 onConfigurationChanged() 方法。</p>
<h6 id="configChanges-orientation"><a href="#configChanges-orientation" class="headerlink" title="configChanges:orientation"></a>configChanges:orientation</h6><p>屏幕方向 “orientation|screenSize”，官方文档这样说</p>
<blockquote>
<p>Beginning with Android 3.2 (API level 13), the “screen size” also changes when the device switches between portrait and landscape orientation. Thus, if you want to prevent runtime restarts due to orientation change when developing for API level 13 or higher (as declared by the minSdkVersion and targetSdkVersion attributes), you must include the “screenSize” value in addition to the “orientation” value. However, if your application targets API level 12 or lower, then your activity always handles this configuration change itself (this configuration change does not restart your activity, even when running on an Android 3.2 or higher device).</p>
</blockquote>
<p>也就是说 API 13 以上的如果要在 configChanges 设置 orientation 时，必须要加上 screenSize 才会有效。但是这里指的 API 13 是在程序中设置的 targetApi, 如果 targetApi 是 13 以下的，那么只设置 orientation 运行在 13 以上的版本上也是可以的。 </p>
<h3 id="关于启动模式"><a href="#关于启动模式" class="headerlink" title="关于启动模式"></a>关于启动模式</h3><p>AActivity 启动 BActivity, 当 B 的启动模式为 standard 或 singleTop, B 启动后会位于 A 所在的栈（除了 A 的启动模式是 singleInstance 外）。所以当 context 启动 Activity 时，由于 context 不是 Activity, 也没有所位于的栈，所以启动的时候需加上标记 FLAG_ACTIVITY_NEW_TASK.<br>当 A 和 B 位于不同栈，并且 B 的启动模式为 singleInstance/singleTask 时，启动后的 B 和 A 不在同一栈内<br>另：taskAffinity 在 AndroidManifest 中声明 Activity 所在的栈，栈名必须包含 “.”</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hexiaosa.com/2018/01/29/Intent_Action/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hexiaosa">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexiaosa">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/29/Intent_Action/" itemprop="url">Intent 的一些 Action 总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-01-29T11:20:58+08:00">
                2018-01-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ol>
<li><p>直接对 data 中的号码拨号 : Intent.ACTION_CALL(android.intent.action.CALL)<br>设置号码（必须）<br>使用此功能注意权限 android.permission.CALL_PHONE</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Intent intent = new Intent();</div><div class="line">intent.setAction(Intent.ACTION_CALL);</div><div class="line">intent.setData(Uri.parse(&quot;tel:22222222&quot;));</div><div class="line">startActivity(intent);</div></pre></td></tr></table></figure>
</li>
<li><p>跳转拨号页面，并且号码是展示的 data 中的 : Intent.ACTION_DIAL(android.intent.action.DIAL)<br>设置号码（可以不设置，不设置就是跳转到拨号界面，不指定号码）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Intent intent = new Intent();</div><div class="line">intent.setAction(Intent.ACTION_DIAL);</div><div class="line">intent.setData(Uri.parse(&quot;tel:手机号&quot;));</div><div class="line">startActivity(intent);</div></pre></td></tr></table></figure>
</li>
<li><p>相当于点击拨号：Intent.ACTION_CALL_BUTTON(android.intent.action.CALL_BUTTON)，直接启动就可以，不用设置其它。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Intent intent = new Intent();</div><div class="line">intent.setAction(Intent.ACTION_CALL_BUTTON);</div><div class="line">startActivity(intent);</div></pre></td></tr></table></figure>
</li>
<li><p>发送短信，Intent.ACTION_SENDTO(android.intent.action.SENDTO) 用法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Intent intent = new Intent();</div><div class="line">intent.setAction(Intent.ACTION_SENDTO);</div><div class="line">intent.setData(Uri.parse(&quot;smsto:收信人&quot;));</div><div class="line">intent.putExtra(&quot;sms_body&quot;, &quot;信息内容：test&quot;);</div><div class="line">startActivity(intent);</div></pre></td></tr></table></figure>
</li>
<li><p>调用系统相机，MediaStore.ACTION_IMAGE_CAPTURE(android.media.action.IMAGE_CAPTURE)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Intent intent = new Intent();</div><div class="line">intent.setAction(MediaStore.ACTION_IMAGE_CAPTURE);</div><div class="line">startActivityForResult(intent, requestCode);</div><div class="line"></div><div class="line">@Override</div><div class="line">protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123;</div><div class="line">    super.onActivityResult(requestCode, resultCode, data);</div><div class="line">    // 获取到拍的照片</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>调用安装应用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Intent install = new Intent(Intent.ACTION_VIEW);</div><div class="line">install.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</div><div class="line">File apkFile = new File(Environment.getExternalStorageDirectory() + &quot;/download/&quot; + &quot;app.apk&quot;;</div><div class="line">install.setDataAndType(Uri.fromFile(apkFile)), &quot;application/vnd.android.package-archive&quot;);</div><div class="line">startActivity(install)</div></pre></td></tr></table></figure></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hexiaosa.com/2018/01/24/java_collection/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hexiaosa">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexiaosa">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/24/java_collection/" itemprop="url">Java 集合简括</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-01-24T17:10:20+08:00">
                2018-01-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>首先放一张全部总结的图<br><img src="/image/Java_collection_sumarize.png" alt="Java_collection_sumarize"></p>
<h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><h6 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h6><p>HashMap 是一个重复 key 值覆盖，键值对形式的集合。<br>HashMap 是用数组加链表的数据结构，put 时要放到数组的某个位置，这个位置的计算是 key 的 hash &amp; (length-1), put 时如果 key 在集合中存在，则直接覆盖掉旧值并返回旧值。如果 key 在集合中不存在，首先会判断是否 size 是不是已经大于数组长度的3/4, 如果是的话就进行数组扩容。然后判断要插入的位置是否已经有元素存在，是的话则使用头插法将该元素插入到该位置的链表中。</p>
<blockquote>
<ol>
<li>HashMap 的长度<br>hashMap 的初始默认长度是 16, 每次扩容的长度都是原长度的 2 倍。每次的 HashMap 数组的长度都是 2 的整数幂，其原因是取 index 时会跟 length-1 做与操作，length-1 的二进制数每位都是 1, 更能降低重复率。<br>如果能在最初预估长度，最好能指定固定长度，这样就避免了扩容，因为扩容的过程会再新建一个 2 倍长度的数组，再计算位置进行复制</li>
<li>冲突解决<br>HashMap put 时的冲突解决方法是拉链法，也就是对于冲突使用链表的形式，这样的优点的是插入快，空间不需要连续，节省空间。</li>
<li>加载因子对性能的影响<br>加载因子默认是 0.75, 其值越大，空间效率越低，冲突越小，查找时间效率越高；其值越小，空间效率越高，冲突越大，查找时间效率越低。</li>
<li>HashMap 是线程不安全的，想要实现线程安全可以通过 Collections.synchronizedCollection 返回 SynchronizedCollection 对象来实现线程安全，或者使用 java.util.concurrent 包下的 ConcurrentHashMap 来实现。</li>
</ol>
</blockquote>
<h6 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h6><p>与 HashMap 相比，支持线程同步，避免多线程同时写而造成的数据不一致，但实现线程同步需要很高的花费，因此不建议用。<br>与 HashMap 相比，其 key, value 不可为 null</p>
<h6 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h6><p>TreeMap是按 key 值有序，相同 key 重复覆盖，非线程安全，内部使用二叉树结构。</p>
<h6 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h6><p>ConcurrentHashMap 是线程安全的，并且相对于 HashTable 来说具有更高的性能。性能更高的原因是尽量减少了加锁的范围、使用 volitile 关键字、CAS，都增加了保证线程安全的性能。<br>从 JDK8 之后加锁开始使用 synchronized 而不是 ReentrantLock, 因为 synchronized 做了足够的优化了。</p>
<h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><h6 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h6><p>以数组形式保存，初始化时可以指定数组长度，不指定的话有默认的长度，每次 add 时检测数组长度是否够用，不够用的话即扩容。如果现有长度是数组长度的 3/4 则开始扩容，扩容的长度是 现有长度 + （内部定义的最小长度或现有长度的 2 2倍）<br>查找效率高，插入，删除都需要移动该元素后面的所有元素。</p>
<h6 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h6><p>与 ArrayList 相比，支持线程同步，避免多线程同时写而造成的数据不一致，但实现线程同步需要很高的花费，因此不建议用。<br>与 ArrayList 相比，Vector 每次扩容都是现有长度的 2 倍</p>
<h6 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h6><p>以双链表形式保存，在头尾插入删除效率高；查找指定位置的会根据要查找的位置来判断从头还是尾开始查。</p>
<h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><h6 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h6><p>无顺序，无重复元素。如果插入的元素已存在，会覆盖已存在的那个。使用的是 HashMap 的 key 来存放。</p>
<h6 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h6><p>有顺序，无重复元素。如果 add 的元素已存在，会覆盖已存在的那个。实际存的就是 TreeMap 的 key.</p>
<h4 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h4><h6 id="PriorityQue"><a href="#PriorityQue" class="headerlink" title="PriorityQue"></a>PriorityQue</h6><p>通过二叉小顶堆实现，保证每次取出的元素都是最小的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hexiaosa.com/2018/01/19/ThreadLocal/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hexiaosa">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexiaosa">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/19/ThreadLocal/" itemprop="url">ThreadLocal 详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-01-19T10:58:37+08:00">
                2018-01-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="1-作用"><a href="#1-作用" class="headerlink" title="1. 作用"></a>1. 作用</h4><p>一个 ThreadLocal 对象在每个线程里面能保存一个值，同一个 ThreadLocal 保存同一个实例在不同线程中互不影响<br>为什么要用它 ——&gt; 在一个线程只需要唯一的某一类型实例</p>
<h4 id="2-怎么用"><a href="#2-怎么用" class="headerlink" title="2. 怎么用"></a>2. 怎么用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class Test&#123;</div><div class="line">	</div><div class="line">	static ThreadLocal&lt;Integer&gt; local = new ThreadLocal&lt;&gt;();</div><div class="line">	</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		local.set(100);</div><div class="line">		new Thread() &#123;</div><div class="line">			public void run() &#123;</div><div class="line">				System.out.println(&quot;new Thread :&quot; + local.get());</div><div class="line">				local.set(200);</div><div class="line">				System.out.println(&quot;new Thread :&quot; + local.get());</div><div class="line">			&#125;;</div><div class="line">		&#125;.start();</div><div class="line">		try &#123;</div><div class="line">			Thread.sleep(10);</div><div class="line">			System.out.println(local.get());</div><div class="line">		&#125; catch (InterruptedException e) &#123;</div><div class="line">			// TODO Auto-generated catch block</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码的输出结果如下，可以看出同一个 ThreadLocal 在不同的线程中有各自的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">new Thread :null</div><div class="line">new Thread :200</div><div class="line">100</div></pre></td></tr></table></figure></p>
<h4 id="3-原理"><a href="#3-原理" class="headerlink" title="3. 原理"></a>3. 原理</h4><p>保存数据的类似 key-value 保存的形式。key 就是当前的 ThreadLocal 对象, set 时如果 key 相同则覆盖 value 的值。<br>那么一个 ThreadLocal 对象是怎么保证一个线程只有一个值的呢？因为 Thread 中有一个 ThreadLocal.ThreadLocalMap 对象，每次 get/set 时都会取出这个对象进行操作。<br><img src="/image/ThreadLocal_get.png" alt="ThreadLocal_get"></p>
<h4 id="4-Android-内源码使用分析"><a href="#4-Android-内源码使用分析" class="headerlink" title="4. Android 内源码使用分析"></a>4. Android 内源码使用分析</h4><p>Looper 在每个线程中只有一个对象，原因在创建 Looper 的源码中有声明一个线程只能有一个 Looper.<br><img src="/image/Looper_prepare.png" alt="Looper_prepare"></p>
<p>具体为什么这样设计从这张图片可能会找到一些答案，有待更进一步研究。<br><img src="/image/Handle_Looper_Message.png" alt="Handle_Looper_Message"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hexiaosa.com/2018/01/09/adb/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hexiaosa">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexiaosa">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/09/adb/" itemprop="url">ADB (Android Debug Bridge)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-01-09T09:56:51+08:00">
                2018-01-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ol>
<li><p>adb 命令和 adb shell 命令的区别：<br> adb 命令是 adb 程序自带的命令，adb shell 命令是 Android 程序的命令，/system/bin/下的命令</p>
</li>
<li><p>一些 adb 命令<br> adb devices<br> adb push local remote<br> adb pull remote local<br> adb install [文件路径]<br> adb uninstall [package name]</p>
</li>
<li><p>一些 adb shell 命令<br> adb shell pm … (list packages, path [package], )<br> adb shell am … (start -a android.intent.action.MAIN [包名]/[路径activity], )<br> adb shell screencap /sdcard/s.png  截屏<br> adb shell screenrecord /sdcard/s.mp4 录制视频，可以指定分辨率等参数<br> adb shell dumpsys activity 查看 activity 任务栈<br> adb shell logcat … (-f [文件路径]&lt;抓日志保存到该文件&gt;, )</p>
</li>
<li><p>adb 用在 android 程序中</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Process p = Runtime.getRuntime().exec(&quot;su/sh&quot;); // su表示root, sh普通用户</div><div class="line">DataOutputStream dataStream = new DataOutputStream(p.getOutputStream());</div><div class="line">dataStream.write(&quot;&quot;.getBytes());// 主要执行的 adb shell 命令</div><div class="line">datastream.writeBytes(&quot;\n&quot;);</div><div class="line"></div><div class="line">dataStream.writeBytes(&quot;exit\n&quot;);</div><div class="line">dataStream.flush();</div><div class="line"></div><div class="line">process.waitFor();</div><div class="line"></div><div class="line">process.getInputStream(); // 成功后输出的信息会放在这里面</div><div class="line">process.getErrorStream(); // 出错后错误信息会放在这里面</div></pre></td></tr></table></figure>
</li>
<li><p>问题：<br> logcat 能否筛选应用?</p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hexiaosa.com/2017/12/17/bluetooth_details/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hexiaosa">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexiaosa">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/17/bluetooth_details/" itemprop="url">Android 蓝牙详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-12-17T17:32:48+08:00">
                2017-12-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>蓝牙4.0提出了低功耗蓝牙的模式。<br>蓝牙4.0的传输分为: Single Mode 和 Dual Mode; Single Mode 只支持与 4.0 的相互传输，Dual Mode 支持与 4.0 以及 3.0, 2.1, 2.0 传输.<br>相关代码如下：</p>
<pre><code>//获取蓝牙适配器，系统只有一个蓝牙适配器，若 adapter 为 null, 则说明系统不支持蓝牙功能
BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();

//表示蓝牙是否打开
adapter.isEnabled();

//获取已配对的蓝牙设备
Set&lt;BluetoothDevice&gt; devices = adapter.getBondedDevices();

BluetoothDevice device = null;
if (devices.iterator().hasNext()) {
    device = devices.iterator().next();
}
if (device == null) {
    //没有已配对的设备
} else {
    //有已配对的设备，连接，发送数据
    //4.0 的传输跟之前的版本有不同，看要连接的设备是否是4.0，是否支持4.0之前的来决定用什么代码来连接
}
</code></pre><p>经典蓝牙连接</p>
<pre><code>权限：
&lt;uses-permission android:name=&quot;android.permission.BLUETOOTH&quot; /&gt;
&lt;uses-permission android:name=&quot;android.permission.BLUETOOTH_ADMIN&quot; /&gt;

BluetoothSocket socket = adapter.createRfcommSocketToServiceRecord(NAME, MY_UUID);
new Thread(
    @Override
    public void run() {
        // 向服务端发送连接
        socket.connect();
        // 获取到输出流，向外写数据
        os = clientSocket.getOutputStream();
        // 判断是否拿到输出流
        if (os != null) {
            // 需要发送的信息
            String text = &quot;open&quot;;
            // 以utf-8的格式发送出去
            os.write(text.getBytes(&quot;UTF-8&quot;));
        }
    }
).start();
</code></pre><p>低功耗蓝牙连接</p>
<pre><code>权限：
&lt;uses-permission android:name=&quot;android.permission.BLUETOOTH&quot; /&gt;
&lt;uses-permission android:name=&quot;android.permission.BLUETOOTH_ADMIN&quot; /&gt;
&lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot; /&gt;
&lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot; /&gt;
&lt;uses-feature
    android:name=&quot;android.hardware.bluetooth_le&quot;
    android:required=&quot;true&quot; /&gt;

BluetoothGatt gatt = device.connGatt(context, autoConnect, BluetoothGattCallback);
//连接蓝牙，连接后将会回调到 BluetoothGattCallback 的 onConnectChanged 方法中
@Override
public void onConnectionStateChange(BluetoothGatt gatt, int status, int newState) {
    super.onConnectionStateChange(gatt, status, newState);
    if (newState == BluetoothProfile.STATE_CONNECTED) {
        //即表示连接成功
        gatt.discoverServices();//该方法之后将会调用 onServiceDiscovered() 方法中
    }
}
@Override
public void onServicesDiscovered(BluetoothGatt gatt, int status) {
    super.onServicesDiscovered(gatt, status);
    //开始发送数据
    sendData();
}

//发送数据，具体怎么发送，要看设备方的要求(怎么接受)，还有需要注意的是 获取服务和获取写入数据的需要设备方提供的UUID与设备相匹配
private void sendData() {
    BluetoothGattService service = mBluetoothGatt.getService(RX_SERVICE_UUID);
    BluetoothGattCharacteristic characteristic = service.getCharacteristic(RX_CHAR_UUID);
    byte[] value = new byte[4];
    value[0] = (byte) &apos;o&apos;;
    value[1] = (byte) &apos;p&apos;;
    value[2] = (byte) &apos;e&apos;;
    value[3] = (byte) &apos;n&apos;;
    characteristic.setValue(value);
    Log.e(&quot;TAG&quot;, &quot;send value -&gt; &quot; + Arrays.toString(characteristic.getValue()));
    boolean isWrite = mBluetoothGatt.writeCharacteristic(characteristic);
    if (isWrite) {
        Log.e(&quot;TAG&quot;, &quot;发送数据成功&quot;);
    } else {
        Log.e(&quot;TAG&quot;, &quot;发送数据失败&quot;);
    }
}
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hexiaosa.com/2017/11/09/about_string/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hexiaosa">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexiaosa">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/09/about_string/" itemprop="url">字符串、整型内存相关</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-11-09T11:32:48+08:00">
                2017-11-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="1-StringBuilder-和字符串连接符"><a href="#1-StringBuilder-和字符串连接符" class="headerlink" title="1. StringBuilder 和字符串连接符"></a>1. StringBuilder 和字符串连接符</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String s = &quot;abc&quot;;</div><div class="line">s += &quot;d&quot;;</div></pre></td></tr></table></figure>
<p>上述代码上，编译器会自动生成更高效的 StringBuilder, 调用 append() 方法来实现。</p>
<p>那么是否表示可以完全信任编译器呢，再看下面代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">String s = &quot;a&quot;;</div><div class="line">for (int i = 0; i &lt; 5; i++) &#123;</div><div class="line">	s += &quot;a&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这种形式的，编译器会在循环体内创建 StringBuilder, 像这种操作，我们应该手动创建 StringBuilder 对象，而不仅仅是依赖编译器。</p>
<p>当然也要避免类似以下的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">StringBuilder s = new StringBuilder();</div><div class="line">for (int i = 0; i &lt; 10; i++) &#123;</div><div class="line">	s.append(&quot;a&quot; + i + &quot;b&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这种代码在循环里面依然有字符串的连接，依然会创建多个 StringBuilder 对象。</p>
<h4 id="2-字符串存储"><a href="#2-字符串存储" class="headerlink" title="2. 字符串存储"></a>2. 字符串存储</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">String s1 = &quot;a&quot;;</div><div class="line">String s2 = &quot;b&quot;;</div><div class="line">String s3 = &quot;a&quot; + &quot;b&quot;;</div><div class="line">System.out.println(&quot;ab == s1+s2&quot; + (&quot;ab&quot; == s1+s2));</div><div class="line">System.out.println(&quot;ab == s3&quot; + (&quot;ab&quot; == s3));</div></pre></td></tr></table></figure>
<p>输出结果：<br>false<br>true<br>直接用引号包裹的字符串相加产生的新对象会放到常量池中，对象相加的不会放到常量池中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public static final String A = &quot;ab&quot;; // 常量A</div><div class="line">public static final String B = &quot;cd&quot;; // 常量B</div><div class="line">// A+B 会放到常量池中，因为 A, B 都是常量，在类编译时已经确定了。</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public static final A;</div><div class="line">public static final B;</div><div class="line">static &#123;</div><div class="line">	A = &quot;a&quot;;</div><div class="line">	B = &quot;b&quot;;</div><div class="line">&#125;</div><div class="line">// A+B 不会放到常量池中，虽然被 final 修饰，但是在后来被赋值，并不是在一开始编译时就确定的。</div></pre></td></tr></table></figure>
<p>intern()方法表示，如果字符串在常量池中存在，就取常量池中的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">String hello = &quot;hello&quot;, lo = &quot;lo&quot;;</div><div class="line">hello == &quot;hel&quot; + &quot;lo&quot;; //true</div><div class="line">hello == &quot;hel&quot; + lo; //false</div><div class="line">hello == (&quot;hel&quot; + lo).intern();  //true</div></pre></td></tr></table></figure></p>
<h4 id="3-Integer-内存分析"><a href="#3-Integer-内存分析" class="headerlink" title="3. Integer 内存分析"></a>3. Integer 内存分析</h4><p>定义一个 Integer 类型，赋值方式</p>
<ol>
<li>Integer i = new Integer(10);</li>
<li>Integer i = 10;</li>
</ol>
<p>对于 -128~127 之间的数，使用第二种赋值方式时如果值相同，则两个变量 “==” true;<br>其它范围的数，两种赋值方式比较结果都为 false.</p>
<p>原因：<br>-128~127 之间的数会存储在常量池中，比较的直接就是存在在常量池中的对象，而其它数都是新建的对象。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hexiaosa.com/2017/11/09/event_dispatch/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hexiaosa">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexiaosa">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/09/event_dispatch/" itemprop="url">事件分发</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-11-09T09:32:48+08:00">
                2017-11-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>事件分发中设计到的几个方法：dispatchTouchEvent(), onInterceptTouchEvent(), onTouchEvent(), 这几个都有返回值 boolean 类型，默认情况下都返回 false, </p>
<p>若有 A(B(MyView)), 则事件的默认传递：</p>
<p>A dispatch<br>A onIntercept<br>B dispatch<br>B onIntercept<br>MyView dispatch<br>MyView onTouch<br>B onTouch<br>A onTouch</p>
<p>当 dispatchTouchEvent 返回 true 时，上面的分发流程就此中止；<br>当 onInterceptTouchEvent 返回 true 时，事件不再往子 View 传递，其余都还正常；<br>当 onTouchEvent 返回 true 时，onTouchEvent 由自己处理，不再交给父级处理。</p>
<p>由上面的分析看来已经很清晰了，有下面这些特殊情况：</p>
<ol>
<li>这几个事件中，ACTION_DOWN 返回 true 和整个事件返回 true 的效果一样。也就是该次 event 一旦返回 true 表示之后的事件都返回 true。</li>
<li>PS: onInterceptTouchEvent() 中有事件返回 true, 则之后的事件该方法不会再被调用，直到本次事件结束。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hexiaosa.com/2017/10/19/note/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hexiaosa">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexiaosa">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/19/note/" itemprop="url">笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-10-19T09:32:48+08:00">
                2017-10-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="最近总结"><a href="#最近总结" class="headerlink" title="最近总结"></a>最近总结</h3><h4 id="1-Serializable-和-Parcelable"><a href="#1-Serializable-和-Parcelable" class="headerlink" title="1. Serializable 和 Parcelable"></a>1. Serializable 和 Parcelable</h4><p>Serializable 和 Parcelable 都是用于序列化的。<br>Serializable 是 Java 中定义的用于序列化的，使用方法是直接实现 Serializable 接口即可;<br>使用 Parcelable 比 Serializable 快大概十倍，因为 Serializable 使用了反射是一个很慢的过程，并且会产生大量的临时对象导致内存回收。</p>
<h4 id="2-Canvas-Bitmap"><a href="#2-Canvas-Bitmap" class="headerlink" title="2. Canvas, Bitmap"></a>2. Canvas, Bitmap</h4><h4 id="4-Binder"><a href="#4-Binder" class="headerlink" title="4. Binder"></a>4. Binder</h4><p>AIDL 文件的本质是系统提供的快速生成 Binder 的工具</p>
<h4 id="5-transient"><a href="#5-transient" class="headerlink" title="5. transient"></a>5. transient</h4><p>transient 的作用是：对于已经序列化的对象，创建实例时前面加上 transient 可以阻止序列化。</p>
<h4 id="7-static-方法重写无效"><a href="#7-static-方法重写无效" class="headerlink" title="7. static 方法重写无效"></a>7. static 方法重写无效</h4><h4 id="8-Java-中的引用："><a href="#8-Java-中的引用：" class="headerlink" title="8. Java 中的引用："></a>8. Java 中的引用：</h4><p>强引用：new 出来的对象<br>软引用：当堆发生 OOM 时会被回收，若回收后内存仍不足，才会发生 OOM.<br>弱引用：WeakReference 只要发生 gc, 就会被回收</p>
<h4 id="9-静态块"><a href="#9-静态块" class="headerlink" title="9. 静态块"></a>9. 静态块</h4><p>执行顺序：静态块 -&gt; 构造函数 -&gt; 调用方法<br>静态块在当前类的调用中只执行一次</p>
<h4 id="10-fail-fast-和-fail-safe"><a href="#10-fail-fast-和-fail-safe" class="headerlink" title="10. fail-fast 和 fail-safe"></a>10. fail-fast 和 fail-safe</h4><p>fail-fast 发生条件：单线程-集合在被访问的过程中内部结构发生修改；多线程-多个线程同时修改同一个集合<br>解决方法就是用 fail-safe 机制，即可以使用 CopyOnWriteArrayList 或 ConCurrentHashMap, 它的实现机制是所有的修改都在一个复制的集合上操作</p>
<h4 id="11-线程池"><a href="#11-线程池" class="headerlink" title="11. 线程池"></a>11. 线程池</h4><p>newCacheThreadPool, 可缓存的线程池<br>newFixedThreadPool， 创建固定数量的线程池<br>newScheduledThreadPool<br>newSingleThreadExcytor, 所有的线程单线程执行</p>
<h4 id="12-canvas"><a href="#12-canvas" class="headerlink" title="12. canvas"></a>12. canvas</h4><p>canvas drawArc 时，paint 需要 setStyle(Paint.Style.STROKE) 才能画成弧，FILL 画成是扇形</p>
<h4 id="13-捕获全局异常-http-www-jianshu-com-p-01b69d91a3a8"><a href="#13-捕获全局异常-http-www-jianshu-com-p-01b69d91a3a8" class="headerlink" title="13. 捕获全局异常  http://www.jianshu.com/p/01b69d91a3a8"></a>13. 捕获全局异常  <a href="http://www.jianshu.com/p/01b69d91a3a8" target="_blank" rel="external">http://www.jianshu.com/p/01b69d91a3a8</a></h4><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">private void handleUncaughtException() &#123;</div><div class="line">	new Handler(Looper.getMainLooper()).post(new Runnable() &#123;</div><div class="line">		@Override</div><div class="line">		public void run() &#123;</div><div class="line">			//主线程异常拦截</div><div class="line">			while (true) &#123;</div><div class="line">				try &#123;</div><div class="line">					Looper.loop();//主线程的异常会从这里抛出</div><div class="line">				&#125; catch (Throwable e) &#123;</div><div class="line">					Log.e(&quot;TAG&quot;, &quot;主线程异常----&quot; + e.getMessage());</div><div class="line">					if (e != null) &#123;</div><div class="line">						handleAfterUncaught();</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;);</div><div class="line">	//所有线程异常拦截，由于主线程的异常都被我们catch住了，所以下面的代码拦截到的都是子线程的异常</div><div class="line">	Thread.setDefaultUncaughtExceptionHandler(new MyException());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><h4 id="14-onDraw-使用"><a href="#14-onDraw-使用" class="headerlink" title="14. onDraw 使用"></a>14. onDraw 使用</h4><p>onDraw 不能做耗时操作，否则会导致界面卡顿。<br>原因：onDraw 引起了 Android 界面渲染，而渲染机制是：系统每 16ms 会执行一次。超过 16ms, 就开始了下次的渲染，导致界面卡顿。</p>
<h4 id="16-ListView"><a href="#16-ListView" class="headerlink" title="16. ListView"></a>16. ListView</h4><ol>
<li><p>使用 ViewHolder 避免了每次都 findViewById, 据测试可以提升 50% 以上的效率</p>
</li>
<li><p>使用 adapter.notifyDataSetChanged() 时，list 需要是同一个对象</p>
</li>
</ol>
<h4 id="17-关于-View"><a href="#17-关于-View" class="headerlink" title="17. 关于 View"></a>17. 关于 View</h4><p>setX(), setY() 和 layout() 的区别</p>
<h4 id="18-移动-View-的方式"><a href="#18-移动-View-的方式" class="headerlink" title="18. 移动 View 的方式"></a>18. 移动 View 的方式</h4><ol>
<li><p>setX(), setY()</p>
</li>
<li><p>layout()</p>
</li>
<li><p>offsetLeftAndRight(), offsetTopAndBottom()</p>
</li>
<li><p>LayoutParams</p>
</li>
<li><p>scrollTo(), scrollBy() 移动的是 View 的内容</p>
</li>
<li><p>Scroller</p>
</li>
<li><p>动画</p>
</li>
</ol>
<h4 id="19-View-事件分发"><a href="#19-View-事件分发" class="headerlink" title="19. View 事件分发"></a>19. View 事件分发</h4><p>以下三个默认都返回 false, 一旦返回 true 就表示拦截事件。<br>若有 A(B(MyView)), 则事件的默认传递：</p>
<p>A dispatch<br>A onIntercept<br>B dispatch<br>B onIntercept<br>MyView dispatch<br>MyView onTouch<br>B onTouch<br>A onTouch</p>
<p>在理解以上分发流程的基础上，以下方法返回 true 代表：<br>dispatchTouchEvent : 事件到此结束，不再继续分发</p>
<p>onInterceptTouchEvent : 拦截事件，不再往子 View 分发</p>
<p>onTouch : 由自己完全处理，事件不再往父 View 传递</p>
<h4 id="20-动画"><a href="#20-动画" class="headerlink" title="20. 动画"></a>20. 动画</h4><h6 id="补间动画-Animation"><a href="#补间动画-Animation" class="headerlink" title="补间动画 (Animation)"></a>补间动画 (Animation)</h6><h6 id="属性动画-Animator"><a href="#属性动画-Animator" class="headerlink" title="属性动画 (Animator)"></a>属性动画 (Animator)</h6><ol>
<li><p>ValueAnimator 的用法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">ValueAnimator valueAnimator = new ValueAnimator(1, 100);</div><div class="line">valueAnimator.setTarget(view);</div><div class="line">valueAnimator.setDuration(500);</div><div class="line">valueAnimator.start();</div><div class="line">valueAnimator.addUpdateListener(new AnimatorUpdateListener()&#123;</div><div class="line">	@Override</div><div class="line">	publid void onAnimationUpdate(ValueAnimator animator) &#123;</div><div class="line">	    Float value = (Float)animator.getAnimatedValue();</div><div class="line">	    //todo use the value</div><div class="line">	&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
<li><p>PropertyValuesHolder 类似AnimatorSet, 多个动画一起执行</p>
</li>
<li>动画的监听，animator.addListener(), new AnimatorListener/AnimatorListenerAdapter</li>
<li>View 的 animate<br>View 可以直接使用 animate() 方法</li>
</ol>
<h6 id="布局动画"><a href="#布局动画" class="headerlink" title="布局动画"></a>布局动画</h6><p>用于 ViewGroup, 用法：</p>
<ol>
<li>xml中在 ViewGroup 声明 animationLayoutDChanges=”true”, 但是测试时并未发现有动画效果</li>
<li>代码中动态添加，如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">LinearLayout ll = (LinearLayout)findViewById(R.id.ll);</div><div class="line"></div><div class="line">ScaleAnimation sa = new ScaleAnimation(0, 1, 0, 1);</div><div class="line">sa.setDuration(500);</div><div class="line"></div><div class="line">LayoutAnimationControllor lac = new LayoutAnimationControlor(sa, 0.5f);</div><div class="line">lac.setOrder(LayoutAnimationControlor.ORDER_NORMAL);</div><div class="line"></div><div class="line">ll.setLayoutAnimationControlor(lac);</div></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="21-清空任务栈"><a href="#21-清空任务栈" class="headerlink" title="21. 清空任务栈"></a>21. 清空任务栈</h4><p>AndroidManifest 中 activity 标签中的几个属性：<br>clearTaskOnLaunch : 每次初始化该 activity, 任务栈就会被清空，只有这一个实例<br>finishOnTaskLaunch : 离开任务栈，再次初始化时，如果有该 activity, 就会被 finish.<br>alwaysRetainTaskState : 给了该 activity 一个免死金牌，永远不会被清理</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Hexiaosa</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">32</span>
                  <span class="site-state-item-name">Artikel</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hexiaosa</span>

  
</div>


  <div class="powered-by">Erstellt mit  <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
